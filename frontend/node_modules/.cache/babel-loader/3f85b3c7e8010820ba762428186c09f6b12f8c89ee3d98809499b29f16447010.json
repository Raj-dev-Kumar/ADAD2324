{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\r\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\r\n * to be big-endian (and the resulting c32 string will be as well).\r\n * @param {string} inputHex - the input to encode\r\n * @param {number} minLength - the minimum length of the c32 string\r\n * @returns {string} the c32check-encoded representation of the data, as a string\r\n */\nfunction c32encode(inputHex, minLength) {\n  // must be hex\n  if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Not a hex-encoded string');\n  }\n  if (inputHex.length % 2 !== 0) {\n    inputHex = `0${inputHex}`;\n  }\n  inputHex = inputHex.toLowerCase();\n  let res = [];\n  let carry = 0;\n  for (let i = inputHex.length - 1; i >= 0; i--) {\n    if (carry < 4) {\n      const currentCode = hex.indexOf(inputHex[i]) >> carry;\n      let nextCode = 0;\n      if (i !== 0) {\n        nextCode = hex.indexOf(inputHex[i - 1]);\n      }\n      // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n      const nextBits = 1 + carry;\n      const nextLowBits = nextCode % (1 << nextBits) << 5 - nextBits;\n      const curC32Digit = exports.c32[currentCode + nextLowBits];\n      carry = nextBits;\n      res.unshift(curC32Digit);\n    } else {\n      carry = 0;\n    }\n  }\n  let C32leadingZeros = 0;\n  for (let i = 0; i < res.length; i++) {\n    if (res[i] !== '0') {\n      break;\n    } else {\n      C32leadingZeros++;\n    }\n  }\n  res = res.slice(C32leadingZeros);\n  const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n  const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n  for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n    res.unshift(exports.c32[0]);\n  }\n  if (minLength) {\n    const count = minLength - res.length;\n    for (let i = 0; i < count; i++) {\n      res.unshift(exports.c32[0]);\n    }\n  }\n  return res.join('');\n}\nexports.c32encode = c32encode;\n/*\r\n * Normalize a c32 string\r\n * @param {string} c32input - the c32-encoded input string\r\n * @returns {string} the canonical representation of the c32 input string\r\n */\nfunction c32normalize(c32input) {\n  // must be upper-case\n  // replace all O's with 0's\n  // replace all I's and L's with 1's\n  return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\r\n * Decode a c32 string back into a hex string.  Note that the c32 input\r\n * string is assumed to be big-endian (and the resulting hex string will\r\n * be as well).\r\n * @param {string} c32input - the c32-encoded input to decode\r\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\r\n * @returns {string} the hex-encoded representation of the data, as a string\r\n */\nfunction c32decode(c32input, minLength) {\n  c32input = c32normalize(c32input);\n  // must result in a c32 string\n  if (!c32input.match(`^[${exports.c32}]*$`)) {\n    throw new Error('Not a c32-encoded string');\n  }\n  const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n  const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n  let res = [];\n  let carry = 0;\n  let carryBits = 0;\n  for (let i = c32input.length - 1; i >= 0; i--) {\n    if (carryBits === 4) {\n      res.unshift(hex[carry]);\n      carryBits = 0;\n      carry = 0;\n    }\n    const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n    const currentValue = currentCode + carry;\n    const currentHexDigit = hex[currentValue % 16];\n    carryBits += 1;\n    carry = currentValue >> 4;\n    if (carry > 1 << carryBits) {\n      throw new Error('Panic error in decoding.');\n    }\n    res.unshift(currentHexDigit);\n  }\n  // one last carry\n  res.unshift(hex[carry]);\n  if (res.length % 2 === 1) {\n    res.unshift('0');\n  }\n  let hexLeadingZeros = 0;\n  for (let i = 0; i < res.length; i++) {\n    if (res[i] !== '0') {\n      break;\n    } else {\n      hexLeadingZeros++;\n    }\n  }\n  res = res.slice(hexLeadingZeros - hexLeadingZeros % 2);\n  let hexStr = res.join('');\n  for (let i = 0; i < numLeadingZeroBytes; i++) {\n    hexStr = `00${hexStr}`;\n  }\n  if (minLength) {\n    const count = minLength * 2 - hexStr.length;\n    for (let i = 0; i < count; i += 2) {\n      hexStr = `00${hexStr}`;\n    }\n  }\n  return hexStr;\n}\nexports.c32decode = c32decode;","map":{"version":3,"names":["Object","defineProperty","exports","value","c32decode","c32normalize","c32encode","c32","utils_1","require","hex","inputHex","minLength","match","Error","length","toLowerCase","res","carry","i","currentCode","indexOf","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","slice","zeroPrefix","TextDecoder","decode","hexToBytes","numLeadingZeroBytesInHex","count","join","c32input","toUpperCase","replace","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr"],"sources":["C:/Users/Pedro/ADAD2324/frontend/node_modules/c32check/lib/encoding.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\r\nconst utils_1 = require(\"@noble/hashes/utils\");\r\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\r\nconst hex = '0123456789abcdef';\r\n/**\r\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\r\n * to be big-endian (and the resulting c32 string will be as well).\r\n * @param {string} inputHex - the input to encode\r\n * @param {number} minLength - the minimum length of the c32 string\r\n * @returns {string} the c32check-encoded representation of the data, as a string\r\n */\r\nfunction c32encode(inputHex, minLength) {\r\n    // must be hex\r\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\r\n        throw new Error('Not a hex-encoded string');\r\n    }\r\n    if (inputHex.length % 2 !== 0) {\r\n        inputHex = `0${inputHex}`;\r\n    }\r\n    inputHex = inputHex.toLowerCase();\r\n    let res = [];\r\n    let carry = 0;\r\n    for (let i = inputHex.length - 1; i >= 0; i--) {\r\n        if (carry < 4) {\r\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\r\n            let nextCode = 0;\r\n            if (i !== 0) {\r\n                nextCode = hex.indexOf(inputHex[i - 1]);\r\n            }\r\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\r\n            const nextBits = 1 + carry;\r\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\r\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\r\n            carry = nextBits;\r\n            res.unshift(curC32Digit);\r\n        }\r\n        else {\r\n            carry = 0;\r\n        }\r\n    }\r\n    let C32leadingZeros = 0;\r\n    for (let i = 0; i < res.length; i++) {\r\n        if (res[i] !== '0') {\r\n            break;\r\n        }\r\n        else {\r\n            C32leadingZeros++;\r\n        }\r\n    }\r\n    res = res.slice(C32leadingZeros);\r\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\r\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\r\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\r\n        res.unshift(exports.c32[0]);\r\n    }\r\n    if (minLength) {\r\n        const count = minLength - res.length;\r\n        for (let i = 0; i < count; i++) {\r\n            res.unshift(exports.c32[0]);\r\n        }\r\n    }\r\n    return res.join('');\r\n}\r\nexports.c32encode = c32encode;\r\n/*\r\n * Normalize a c32 string\r\n * @param {string} c32input - the c32-encoded input string\r\n * @returns {string} the canonical representation of the c32 input string\r\n */\r\nfunction c32normalize(c32input) {\r\n    // must be upper-case\r\n    // replace all O's with 0's\r\n    // replace all I's and L's with 1's\r\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\r\n}\r\nexports.c32normalize = c32normalize;\r\n/*\r\n * Decode a c32 string back into a hex string.  Note that the c32 input\r\n * string is assumed to be big-endian (and the resulting hex string will\r\n * be as well).\r\n * @param {string} c32input - the c32-encoded input to decode\r\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\r\n * @returns {string} the hex-encoded representation of the data, as a string\r\n */\r\nfunction c32decode(c32input, minLength) {\r\n    c32input = c32normalize(c32input);\r\n    // must result in a c32 string\r\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\r\n        throw new Error('Not a c32-encoded string');\r\n    }\r\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\r\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\r\n    let res = [];\r\n    let carry = 0;\r\n    let carryBits = 0;\r\n    for (let i = c32input.length - 1; i >= 0; i--) {\r\n        if (carryBits === 4) {\r\n            res.unshift(hex[carry]);\r\n            carryBits = 0;\r\n            carry = 0;\r\n        }\r\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\r\n        const currentValue = currentCode + carry;\r\n        const currentHexDigit = hex[currentValue % 16];\r\n        carryBits += 1;\r\n        carry = currentValue >> 4;\r\n        if (carry > 1 << carryBits) {\r\n            throw new Error('Panic error in decoding.');\r\n        }\r\n        res.unshift(currentHexDigit);\r\n    }\r\n    // one last carry\r\n    res.unshift(hex[carry]);\r\n    if (res.length % 2 === 1) {\r\n        res.unshift('0');\r\n    }\r\n    let hexLeadingZeros = 0;\r\n    for (let i = 0; i < res.length; i++) {\r\n        if (res[i] !== '0') {\r\n            break;\r\n        }\r\n        else {\r\n            hexLeadingZeros++;\r\n        }\r\n    }\r\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\r\n    let hexStr = res.join('');\r\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\r\n        hexStr = `00${hexStr}`;\r\n    }\r\n    if (minLength) {\r\n        const count = minLength * 2 - hexStr.length;\r\n        for (let i = 0; i < count; i += 2) {\r\n            hexStr = `00${hexStr}`;\r\n        }\r\n    }\r\n    return hexStr;\r\n}\r\nexports.c32decode = c32decode;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}