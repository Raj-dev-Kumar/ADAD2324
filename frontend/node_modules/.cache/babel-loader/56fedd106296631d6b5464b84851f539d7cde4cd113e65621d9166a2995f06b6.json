{"ast":null,"code":"import { concatBytes } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n  constructor(createCipher, createDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n  async encrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n  async decrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\n    return Promise.resolve(result);\n  }\n}\nexport class WebCryptoAesCipher {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n  async encrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['encrypt']);\n    const result = await this.subtleCrypto.encrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n  async decrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['decrypt']);\n    const result = await this.subtleCrypto.decrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return new Uint8Array(result);\n  }\n}\nexport async function createCipher() {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  }\n  return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n}","map":{"version":3,"names":["concatBytes","getCryptoLib","NodeCryptoAesCipher","constructor","createCipher","createDecipher","encrypt","algorithm","key","iv","data","Error","cipher","result","Uint8Array","update","final","Promise","resolve","decrypt","WebCryptoAesCipher","subtleCrypto","algo","length","cryptoKey","importKey","name","cryptoLib","lib","createCipheriv","createDecipheriv"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\encryption\\src\\aesCipher.ts"],"sourcesContent":["import { concatBytes } from '@stacks/common';\r\nimport { getCryptoLib } from './cryptoUtils';\r\n\r\ntype NodeCryptoCreateCipher = typeof import('crypto').createCipheriv;\r\ntype NodeCryptoCreateDecipher = typeof import('crypto').createDecipheriv;\r\n\r\nexport type CipherAlgorithm = 'aes-256-cbc' | 'aes-128-cbc';\r\n\r\nexport interface AesCipher {\r\n  encrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array>;\r\n\r\n  decrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array>;\r\n}\r\n\r\nexport class NodeCryptoAesCipher implements AesCipher {\r\n  createCipher: NodeCryptoCreateCipher;\r\n\r\n  createDecipher: NodeCryptoCreateDecipher;\r\n\r\n  constructor(createCipher: NodeCryptoCreateCipher, createDecipher: NodeCryptoCreateDecipher) {\r\n    this.createCipher = createCipher;\r\n    this.createDecipher = createDecipher;\r\n  }\r\n\r\n  async encrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array> {\r\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\r\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\r\n    }\r\n    const cipher = this.createCipher(algorithm, key, iv);\r\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\r\n    return Promise.resolve(result);\r\n  }\r\n\r\n  async decrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array> {\r\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\r\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\r\n    }\r\n    const cipher = this.createDecipher(algorithm, key, iv);\r\n    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));\r\n    return Promise.resolve(result);\r\n  }\r\n}\r\n\r\nexport class WebCryptoAesCipher implements AesCipher {\r\n  subtleCrypto: SubtleCrypto;\r\n\r\n  constructor(subtleCrypto: SubtleCrypto) {\r\n    this.subtleCrypto = subtleCrypto;\r\n  }\r\n\r\n  async encrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array> {\r\n    let algo: string;\r\n    let length: number;\r\n    if (algorithm === 'aes-128-cbc') {\r\n      algo = 'AES-CBC';\r\n      length = 128;\r\n    } else if (algorithm === 'aes-256-cbc') {\r\n      algo = 'AES-CBC';\r\n      length = 256;\r\n    } else {\r\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\r\n    }\r\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\r\n      'encrypt',\r\n    ]);\r\n    const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\r\n    return new Uint8Array(result);\r\n  }\r\n\r\n  async decrypt(\r\n    algorithm: CipherAlgorithm,\r\n    key: Uint8Array,\r\n    iv: Uint8Array,\r\n    data: Uint8Array\r\n  ): Promise<Uint8Array> {\r\n    let algo: string;\r\n    let length: number;\r\n    if (algorithm === 'aes-128-cbc') {\r\n      algo = 'AES-CBC';\r\n      length = 128;\r\n    } else if (algorithm === 'aes-256-cbc') {\r\n      algo = 'AES-CBC';\r\n      length = 256;\r\n    } else {\r\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\r\n    }\r\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\r\n      'decrypt',\r\n    ]);\r\n    const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\r\n    return new Uint8Array(result);\r\n  }\r\n}\r\n\r\nexport async function createCipher(): Promise<AesCipher> {\r\n  const cryptoLib = await getCryptoLib();\r\n  if (cryptoLib.name === 'subtleCrypto') {\r\n    return new WebCryptoAesCipher(cryptoLib.lib);\r\n  }\r\n  return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}