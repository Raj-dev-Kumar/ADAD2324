{"ast":null,"code":"import { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\nexport function cvToString(val, encoding = 'hex') {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${cvToString(val.data[key], encoding)})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\nexport function cvToValue(val, strictJsonCompat = false) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\nexport function cvToJSON(val) {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: false\n      };\n    case ClarityType.ResponseOk:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: true\n      };\n    default:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true)\n      };\n  }\n}\nexport function getCVTypeString(val) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${getCVTypeString(val.data[key])})`).join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}","map":{"version":3,"names":["principalToString","ClarityType","asciiToBytes","bytesToAscii","bytesToHex","utf8ToBytes","cvToString","val","encoding","type","BoolTrue","BoolFalse","Int","value","toString","UInt","Buffer","str","buffer","test","JSON","stringify","OptionalNone","OptionalSome","ResponseErr","ResponseOk","PrincipalStandard","PrincipalContract","List","list","map","v","join","Tuple","Object","keys","data","key","StringASCII","StringUTF8","cvToValue","strictJsonCompat","cvToJSON","result","forEach","getCVTypeString","success","length"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\clarity\\clarityValue.ts"],"sourcesContent":["import {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nimport { asciiToBytes, bytesToAscii, bytesToHex, utf8ToBytes } from '@stacks/common';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = bytesToAscii(val.buffer);\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      }\n      return val.value;\n    case ClarityType.Buffer:\n      return `0x${bytesToHex(val.buffer)}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${asciiToBytes(val.data).length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${utf8ToBytes(val.data).length})`;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}