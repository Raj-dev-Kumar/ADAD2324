{"ast":null,"code":"import { concatArray, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\nimport { deserializeCV, serializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nimport { createAddress, createLPString } from './postcondition-types';\nimport { codeBodyString, createMemoString, deserializeAddress, deserializeLPString, deserializeMemoString, serializeStacksMessage } from './types';\nexport function isTokenTransferPayload(p) {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p) {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p) {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p) {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p) {\n  return p.payloadType === PayloadType.Coinbase;\n}\nexport function createTokenTransferPayload(recipient, amount, memo) {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString('')\n  };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs\n  };\n}\nexport function createSmartContractPayload(contractName, codeBody, clarityVersion) {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion,\n      contractName,\n      codeBody\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody\n  };\n}\nexport function createPoisonPayload() {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.PoisonMicroblock\n  };\n}\nexport function createCoinbasePayload(coinbaseBytes, altRecipient) {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes,\n      recipient: altRecipient\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes\n  };\n}\nexport function serializePayload(payload) {\n  const bytesArray = [];\n  bytesArray.push(payload.payloadType);\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializePayload(bytesReader) {\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bytesReader);\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\n      const memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bytesReader);\n      const contractCallName = deserializeLPString(bytesReader);\n      const functionName = deserializeLPString(bytesReader);\n      const functionArgs = [];\n      const numberOfArgs = bytesReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.VersionedSmartContract:\n      {\n        const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\n          throw new Error(`Cannot recognize ClarityVersion: ${n}`);\n        });\n        const smartContractName = deserializeLPString(bytesReader);\n        const codeBody = deserializeLPString(bytesReader, 4, 100000);\n        return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\n      }\n    case PayloadType.PoisonMicroblock:\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    case PayloadType.CoinbaseToAltRecipient:\n      const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const altRecipient = deserializeCV(bytesReader);\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\n  }\n}","map":{"version":3,"names":["concatArray","intToBigInt","intToBytes","writeUInt32BE","ClarityVersion","COINBASE_BYTES_LENGTH","PayloadType","StacksMessageType","deserializeCV","serializeCV","principalCV","createAddress","createLPString","codeBodyString","createMemoString","deserializeAddress","deserializeLPString","deserializeMemoString","serializeStacksMessage","isTokenTransferPayload","p","payloadType","TokenTransfer","isContractCallPayload","ContractCall","isSmartContractPayload","SmartContract","isPoisonPayload","PoisonMicroblock","isCoinbasePayload","Coinbase","createTokenTransferPayload","recipient","amount","memo","type","Payload","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createSmartContractPayload","codeBody","clarityVersion","VersionedSmartContract","createPoisonPayload","createCoinbasePayload","coinbaseBytes","altRecipient","byteLength","Error","undefined","CoinbaseToAltRecipient","serializePayload","payload","bytesArray","push","numArgs","Uint8Array","length","forEach","arg","deserializePayload","bytesReader","readUInt8Enum","n","readBytes","contractCallName","numberOfArgs","readUInt32BE","i","clarityValue","smartContractName","coinbaseToAltRecipientBuffer"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\payload.ts"],"sourcesContent":["import { concatArray, IntegerType, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\r\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\r\n\r\nimport { BytesReader } from './bytesReader';\r\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity/';\r\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\r\nimport { Address } from './common';\r\nimport { createAddress, createLPString, LengthPrefixedString } from './postcondition-types';\r\nimport {\r\n  codeBodyString,\r\n  createMemoString,\r\n  deserializeAddress,\r\n  deserializeLPString,\r\n  deserializeMemoString,\r\n  MemoString,\r\n  serializeStacksMessage,\r\n} from './types';\r\n\r\nexport type Payload =\r\n  | TokenTransferPayload\r\n  | ContractCallPayload\r\n  | SmartContractPayload\r\n  | VersionedSmartContractPayload\r\n  | PoisonPayload\r\n  | CoinbasePayload\r\n  | CoinbasePayloadToAltRecipient;\r\n\r\nexport function isTokenTransferPayload(p: Payload): p is TokenTransferPayload {\r\n  return p.payloadType === PayloadType.TokenTransfer;\r\n}\r\nexport function isContractCallPayload(p: Payload): p is ContractCallPayload {\r\n  return p.payloadType === PayloadType.ContractCall;\r\n}\r\nexport function isSmartContractPayload(p: Payload): p is SmartContractPayload {\r\n  return p.payloadType === PayloadType.SmartContract;\r\n}\r\nexport function isPoisonPayload(p: Payload): p is PoisonPayload {\r\n  return p.payloadType === PayloadType.PoisonMicroblock;\r\n}\r\nexport function isCoinbasePayload(p: Payload): p is CoinbasePayload {\r\n  return p.payloadType === PayloadType.Coinbase;\r\n}\r\n\r\nexport interface TokenTransferPayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.TokenTransfer;\r\n  readonly recipient: PrincipalCV;\r\n  readonly amount: bigint;\r\n  readonly memo: MemoString;\r\n}\r\n\r\nexport type PayloadInput =\r\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\r\n  | ContractCallPayload\r\n  | SmartContractPayload\r\n  | VersionedSmartContractPayload\r\n  | PoisonPayload\r\n  | CoinbasePayload\r\n  | CoinbasePayloadToAltRecipient;\r\n\r\nexport function createTokenTransferPayload(\r\n  recipient: string | PrincipalCV,\r\n  amount: IntegerType,\r\n  memo?: string | MemoString\r\n): TokenTransferPayload {\r\n  if (typeof recipient === 'string') {\r\n    recipient = principalCV(recipient);\r\n  }\r\n  if (typeof memo === 'string') {\r\n    memo = createMemoString(memo);\r\n  }\r\n\r\n  return {\r\n    type: StacksMessageType.Payload,\r\n    payloadType: PayloadType.TokenTransfer,\r\n    recipient,\r\n    amount: intToBigInt(amount, false),\r\n    memo: memo ?? createMemoString(''),\r\n  };\r\n}\r\n\r\nexport interface ContractCallPayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.ContractCall;\r\n  readonly contractAddress: Address;\r\n  readonly contractName: LengthPrefixedString;\r\n  readonly functionName: LengthPrefixedString;\r\n  readonly functionArgs: ClarityValue[];\r\n}\r\n\r\nexport function createContractCallPayload(\r\n  contractAddress: string | Address,\r\n  contractName: string | LengthPrefixedString,\r\n  functionName: string | LengthPrefixedString,\r\n  functionArgs: ClarityValue[]\r\n): ContractCallPayload {\r\n  if (typeof contractAddress === 'string') {\r\n    contractAddress = createAddress(contractAddress);\r\n  }\r\n  if (typeof contractName === 'string') {\r\n    contractName = createLPString(contractName);\r\n  }\r\n  if (typeof functionName === 'string') {\r\n    functionName = createLPString(functionName);\r\n  }\r\n\r\n  return {\r\n    type: StacksMessageType.Payload,\r\n    payloadType: PayloadType.ContractCall,\r\n    contractAddress,\r\n    contractName,\r\n    functionName,\r\n    functionArgs,\r\n  };\r\n}\r\n\r\nexport interface SmartContractPayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.SmartContract;\r\n  readonly contractName: LengthPrefixedString;\r\n  readonly codeBody: LengthPrefixedString;\r\n}\r\n\r\nexport interface VersionedSmartContractPayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.VersionedSmartContract;\r\n  readonly clarityVersion: ClarityVersion;\r\n  readonly contractName: LengthPrefixedString;\r\n  readonly codeBody: LengthPrefixedString;\r\n}\r\n\r\nexport function createSmartContractPayload(\r\n  contractName: string | LengthPrefixedString,\r\n  codeBody: string | LengthPrefixedString,\r\n  clarityVersion?: ClarityVersion\r\n): SmartContractPayload | VersionedSmartContractPayload {\r\n  if (typeof contractName === 'string') {\r\n    contractName = createLPString(contractName);\r\n  }\r\n  if (typeof codeBody === 'string') {\r\n    codeBody = codeBodyString(codeBody);\r\n  }\r\n\r\n  if (typeof clarityVersion === 'number') {\r\n    return {\r\n      type: StacksMessageType.Payload,\r\n      payloadType: PayloadType.VersionedSmartContract,\r\n      clarityVersion,\r\n      contractName,\r\n      codeBody,\r\n    };\r\n  }\r\n  return {\r\n    type: StacksMessageType.Payload,\r\n    payloadType: PayloadType.SmartContract,\r\n    contractName,\r\n    codeBody,\r\n  };\r\n}\r\n\r\nexport interface PoisonPayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.PoisonMicroblock;\r\n}\r\n\r\nexport function createPoisonPayload(): PoisonPayload {\r\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\r\n}\r\n\r\nexport interface CoinbasePayload {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.Coinbase;\r\n  readonly coinbaseBytes: Uint8Array;\r\n}\r\n\r\nexport interface CoinbasePayloadToAltRecipient {\r\n  readonly type: StacksMessageType.Payload;\r\n  readonly payloadType: PayloadType.CoinbaseToAltRecipient;\r\n  readonly coinbaseBytes: Uint8Array;\r\n  readonly recipient: PrincipalCV;\r\n}\r\n\r\nexport function createCoinbasePayload(\r\n  coinbaseBytes: Uint8Array,\r\n  altRecipient?: PrincipalCV\r\n): CoinbasePayload | CoinbasePayloadToAltRecipient {\r\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\r\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\r\n  }\r\n\r\n  if (altRecipient != undefined) {\r\n    return {\r\n      type: StacksMessageType.Payload,\r\n      payloadType: PayloadType.CoinbaseToAltRecipient,\r\n      coinbaseBytes,\r\n      recipient: altRecipient,\r\n    };\r\n  }\r\n  return {\r\n    type: StacksMessageType.Payload,\r\n    payloadType: PayloadType.Coinbase,\r\n    coinbaseBytes,\r\n  };\r\n}\r\n\r\nexport function serializePayload(payload: PayloadInput): Uint8Array {\r\n  const bytesArray = [];\r\n  bytesArray.push(payload.payloadType);\r\n\r\n  switch (payload.payloadType) {\r\n    case PayloadType.TokenTransfer:\r\n      bytesArray.push(serializeCV(payload.recipient));\r\n      bytesArray.push(intToBytes(payload.amount, false, 8));\r\n      bytesArray.push(serializeStacksMessage(payload.memo));\r\n      break;\r\n    case PayloadType.ContractCall:\r\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\r\n      bytesArray.push(serializeStacksMessage(payload.contractName));\r\n      bytesArray.push(serializeStacksMessage(payload.functionName));\r\n      const numArgs = new Uint8Array(4);\r\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\r\n      bytesArray.push(numArgs);\r\n      payload.functionArgs.forEach(arg => {\r\n        bytesArray.push(serializeCV(arg));\r\n      });\r\n      break;\r\n    case PayloadType.SmartContract:\r\n      bytesArray.push(serializeStacksMessage(payload.contractName));\r\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\r\n      break;\r\n    case PayloadType.VersionedSmartContract:\r\n      bytesArray.push(payload.clarityVersion);\r\n      bytesArray.push(serializeStacksMessage(payload.contractName));\r\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\r\n      break;\r\n    case PayloadType.PoisonMicroblock:\r\n      // TODO: implement\r\n      break;\r\n    case PayloadType.Coinbase:\r\n      bytesArray.push(payload.coinbaseBytes);\r\n      break;\r\n    case PayloadType.CoinbaseToAltRecipient:\r\n      bytesArray.push(payload.coinbaseBytes);\r\n      bytesArray.push(serializeCV(payload.recipient));\r\n      break;\r\n  }\r\n\r\n  return concatArray(bytesArray);\r\n}\r\n\r\nexport function deserializePayload(bytesReader: BytesReader): Payload {\r\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\r\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\r\n  });\r\n\r\n  switch (payloadType) {\r\n    case PayloadType.TokenTransfer:\r\n      const recipient = deserializeCV(bytesReader) as PrincipalCV;\r\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\r\n      const memo = deserializeMemoString(bytesReader);\r\n      return createTokenTransferPayload(recipient, amount, memo);\r\n    case PayloadType.ContractCall:\r\n      const contractAddress = deserializeAddress(bytesReader);\r\n      const contractCallName = deserializeLPString(bytesReader);\r\n      const functionName = deserializeLPString(bytesReader);\r\n      const functionArgs: ClarityValue[] = [];\r\n      const numberOfArgs = bytesReader.readUInt32BE();\r\n      for (let i = 0; i < numberOfArgs; i++) {\r\n        const clarityValue = deserializeCV(bytesReader);\r\n        functionArgs.push(clarityValue);\r\n      }\r\n      return createContractCallPayload(\r\n        contractAddress,\r\n        contractCallName,\r\n        functionName,\r\n        functionArgs\r\n      );\r\n    case PayloadType.SmartContract:\r\n      const smartContractName = deserializeLPString(bytesReader);\r\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\r\n      return createSmartContractPayload(smartContractName, codeBody);\r\n\r\n    case PayloadType.VersionedSmartContract: {\r\n      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\r\n        throw new Error(`Cannot recognize ClarityVersion: ${n}`);\r\n      });\r\n      const smartContractName = deserializeLPString(bytesReader);\r\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\r\n      return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\r\n    }\r\n    case PayloadType.PoisonMicroblock:\r\n      // TODO: implement\r\n      return createPoisonPayload();\r\n    case PayloadType.Coinbase:\r\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\r\n      return createCoinbasePayload(coinbaseBytes);\r\n    case PayloadType.CoinbaseToAltRecipient:\r\n      const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\r\n      const altRecipient = deserializeCV(bytesReader) as PrincipalCV;\r\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}