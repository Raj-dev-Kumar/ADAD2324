{"ast":null,"code":"import { bytesToHex, concatArray, hexToBytes, intToBigInt, writeUInt32BE } from '@stacks/common';\nimport { AnchorMode, anchorModeFromNameOrValue, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { deserializeAuthorization, intoInitialSighashAuth, isSingleSig, nextSignature, serializeAuthorization, setFee, setNonce, setSponsor, setSponsorNonce, verifyOrigin } from './authorization';\nimport { createTransactionAuthField } from './signature';\nimport { cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BytesReader } from './bytesReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n  constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false)\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n  verifyOrigin() {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n  signNextOrigin(sigHash, privateKey) {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n  signNextSponsor(sigHash, privateKey) {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n  appendPubkey(publicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n  signAndAppend(condition, curSigHash, authType, privateKey) {\n    const {\n      nextSig,\n      nextSigHash\n    } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = bytesToHex(privateKey.data).endsWith('01');\n      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n    }\n    return nextSigHash;\n  }\n  txid() {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n  setSponsor(sponsorSpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n  setFee(amount) {\n    this.auth = setFee(this.auth, amount);\n  }\n  setNonce(nonce) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n  setSponsorNonce(nonce) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n  serialize() {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n    const bytesArray = [];\n    bytesArray.push(this.version);\n    const chainIdBytes = new Uint8Array(4);\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\n    bytesArray.push(chainIdBytes);\n    bytesArray.push(serializeAuthorization(this.auth));\n    bytesArray.push(this.anchorMode);\n    bytesArray.push(this.postConditionMode);\n    bytesArray.push(serializeLPList(this.postConditions));\n    bytesArray.push(serializePayload(this.payload));\n    return concatArray(bytesArray);\n  }\n}\nexport function deserializeTransaction(data) {\n  let bytesReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(data));\n    }\n  } else if (data instanceof Uint8Array) {\n    bytesReader = new BytesReader(data);\n  } else {\n    bytesReader = data;\n  }\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bytesReader.readUInt32BE();\n  const auth = deserializeAuthorization(bytesReader);\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bytesReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"names":["bytesToHex","concatArray","hexToBytes","intToBigInt","writeUInt32BE","AnchorMode","anchorModeFromNameOrValue","AuthType","DEFAULT_CHAIN_ID","PayloadType","PostConditionMode","PubKeyEncoding","StacksMessageType","TransactionVersion","deserializeAuthorization","intoInitialSighashAuth","isSingleSig","nextSignature","serializeAuthorization","setFee","setNonce","setSponsor","setSponsorNonce","verifyOrigin","createTransactionAuthField","cloneDeep","txidFromData","deserializePayload","serializePayload","createLPList","deserializeLPList","serializeLPList","isCompressed","BytesReader","SerializationError","SigningError","StacksTransaction","constructor","version","auth","payload","postConditions","postConditionMode","anchorMode","chainId","amount","Deny","payloadType","Coinbase","CoinbaseToAltRecipient","PoisonMicroblock","OnChainOnly","ContractCall","SmartContract","VersionedSmartContract","TokenTransfer","Any","signBegin","tx","txid","verifyBegin","signNextOrigin","sigHash","privateKey","spendingCondition","undefined","Error","authType","signAndAppend","Standard","signNextSponsor","Sponsored","sponsorSpendingCondition","appendPubkey","publicKey","cond","compressed","fields","push","Compressed","Uncompressed","condition","curSigHash","nextSig","nextSigHash","fee","nonce","signature","data","endsWith","serialized","serialize","bytesArray","chainIdBytes","Uint8Array","deserializeTransaction","bytesReader","slice","toLowerCase","readUInt8Enum","n","readUInt32BE","PostCondition"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\transaction.ts"],"sourcesContent":["import {\r\n  bytesToHex,\r\n  concatArray,\r\n  hexToBytes,\r\n  IntegerType,\r\n  intToBigInt,\r\n  writeUInt32BE,\r\n} from '@stacks/common';\r\nimport {\r\n  AnchorMode,\r\n  anchorModeFromNameOrValue,\r\n  AnchorModeName,\r\n  AuthType,\r\n  ChainID,\r\n  DEFAULT_CHAIN_ID,\r\n  PayloadType,\r\n  PostConditionMode,\r\n  PubKeyEncoding,\r\n  StacksMessageType,\r\n  TransactionVersion,\r\n} from './constants';\r\n\r\nimport {\r\n  Authorization,\r\n  deserializeAuthorization,\r\n  intoInitialSighashAuth,\r\n  isSingleSig,\r\n  nextSignature,\r\n  serializeAuthorization,\r\n  setFee,\r\n  setNonce,\r\n  setSponsor,\r\n  setSponsorNonce,\r\n  SpendingConditionOpts,\r\n  verifyOrigin,\r\n} from './authorization';\r\nimport { createTransactionAuthField } from './signature';\r\n\r\nimport { cloneDeep, txidFromData } from './utils';\r\n\r\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\r\n\r\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\r\n\r\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\r\n\r\nimport { BytesReader } from './bytesReader';\r\n\r\nimport { SerializationError, SigningError } from './errors';\r\n\r\nexport class StacksTransaction {\r\n  version: TransactionVersion;\r\n  chainId: ChainID;\r\n  auth: Authorization;\r\n  anchorMode: AnchorMode;\r\n  payload: Payload;\r\n  postConditionMode: PostConditionMode;\r\n  postConditions: LengthPrefixedList;\r\n\r\n  constructor(\r\n    version: TransactionVersion,\r\n    auth: Authorization,\r\n    payload: PayloadInput,\r\n    postConditions?: LengthPrefixedList,\r\n    postConditionMode?: PostConditionMode,\r\n    anchorMode?: AnchorModeName | AnchorMode,\r\n    chainId?: ChainID\r\n  ) {\r\n    this.version = version;\r\n    this.auth = auth;\r\n    if ('amount' in payload) {\r\n      this.payload = {\r\n        ...payload,\r\n        amount: intToBigInt(payload.amount, false),\r\n      };\r\n    } else {\r\n      this.payload = payload;\r\n    }\r\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\r\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\r\n    this.postConditions = postConditions ?? createLPList([]);\r\n\r\n    if (anchorMode) {\r\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\r\n    } else {\r\n      switch (payload.payloadType) {\r\n        case PayloadType.Coinbase:\r\n        case PayloadType.CoinbaseToAltRecipient:\r\n        case PayloadType.PoisonMicroblock: {\r\n          this.anchorMode = AnchorMode.OnChainOnly;\r\n          break;\r\n        }\r\n        case PayloadType.ContractCall:\r\n        case PayloadType.SmartContract:\r\n        case PayloadType.VersionedSmartContract:\r\n        case PayloadType.TokenTransfer: {\r\n          this.anchorMode = AnchorMode.Any;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  signBegin() {\r\n    const tx = cloneDeep(this);\r\n    tx.auth = intoInitialSighashAuth(tx.auth);\r\n    return tx.txid();\r\n  }\r\n\r\n  verifyBegin() {\r\n    const tx = cloneDeep(this);\r\n    tx.auth = intoInitialSighashAuth(tx.auth);\r\n    return tx.txid();\r\n  }\r\n\r\n  verifyOrigin(): string {\r\n    return verifyOrigin(this.auth, this.verifyBegin());\r\n  }\r\n\r\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\r\n    if (this.auth.spendingCondition === undefined) {\r\n      throw new Error('\"auth.spendingCondition\" is undefined');\r\n    }\r\n    if (this.auth.authType === undefined) {\r\n      throw new Error('\"auth.authType\" is undefined');\r\n    }\r\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\r\n  }\r\n\r\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\r\n    if (this.auth.authType === AuthType.Sponsored) {\r\n      return this.signAndAppend(\r\n        this.auth.sponsorSpendingCondition,\r\n        sigHash,\r\n        AuthType.Sponsored,\r\n        privateKey\r\n      );\r\n    } else {\r\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\r\n    }\r\n  }\r\n\r\n  appendPubkey(publicKey: StacksPublicKey) {\r\n    const cond = this.auth.spendingCondition;\r\n    if (cond && !isSingleSig(cond)) {\r\n      const compressed = isCompressed(publicKey);\r\n      cond.fields.push(\r\n        createTransactionAuthField(\r\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\r\n          publicKey\r\n        )\r\n      );\r\n    } else {\r\n      throw new Error(`Can't append public key to a singlesig condition`);\r\n    }\r\n  }\r\n\r\n  signAndAppend(\r\n    condition: SpendingConditionOpts,\r\n    curSigHash: string,\r\n    authType: AuthType,\r\n    privateKey: StacksPrivateKey\r\n  ): string {\r\n    const { nextSig, nextSigHash } = nextSignature(\r\n      curSigHash,\r\n      authType,\r\n      condition.fee,\r\n      condition.nonce,\r\n      privateKey\r\n    );\r\n    if (isSingleSig(condition)) {\r\n      condition.signature = nextSig;\r\n    } else {\r\n      const compressed = bytesToHex(privateKey.data).endsWith('01');\r\n      condition.fields.push(\r\n        createTransactionAuthField(\r\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\r\n          nextSig\r\n        )\r\n      );\r\n    }\r\n\r\n    return nextSigHash;\r\n  }\r\n\r\n  txid(): string {\r\n    const serialized = this.serialize();\r\n    return txidFromData(serialized);\r\n  }\r\n\r\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\r\n    if (this.auth.authType != AuthType.Sponsored) {\r\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\r\n    }\r\n\r\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\r\n  }\r\n\r\n  /**\r\n   * Set the total fee to be paid for this transaction\r\n   *\r\n   * @param fee - the fee amount in microstacks\r\n   */\r\n  setFee(amount: IntegerType) {\r\n    this.auth = setFee(this.auth, amount);\r\n  }\r\n\r\n  /**\r\n   * Set the transaction nonce\r\n   *\r\n   * @param nonce - the nonce value\r\n   */\r\n  setNonce(nonce: IntegerType) {\r\n    this.auth = setNonce(this.auth, nonce);\r\n  }\r\n\r\n  /**\r\n   * Set the transaction sponsor nonce\r\n   *\r\n   * @param nonce - the sponsor nonce value\r\n   */\r\n  setSponsorNonce(nonce: IntegerType) {\r\n    if (this.auth.authType != AuthType.Sponsored) {\r\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\r\n    }\r\n\r\n    this.auth = setSponsorNonce(this.auth, nonce);\r\n  }\r\n\r\n  serialize(): Uint8Array {\r\n    if (this.version === undefined) {\r\n      throw new SerializationError('\"version\" is undefined');\r\n    }\r\n    if (this.chainId === undefined) {\r\n      throw new SerializationError('\"chainId\" is undefined');\r\n    }\r\n    if (this.auth === undefined) {\r\n      throw new SerializationError('\"auth\" is undefined');\r\n    }\r\n    if (this.anchorMode === undefined) {\r\n      throw new SerializationError('\"anchorMode\" is undefined');\r\n    }\r\n    if (this.payload === undefined) {\r\n      throw new SerializationError('\"payload\" is undefined');\r\n    }\r\n\r\n    const bytesArray = [];\r\n\r\n    bytesArray.push(this.version);\r\n    const chainIdBytes = new Uint8Array(4);\r\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\r\n    bytesArray.push(chainIdBytes);\r\n    bytesArray.push(serializeAuthorization(this.auth));\r\n    bytesArray.push(this.anchorMode);\r\n    bytesArray.push(this.postConditionMode);\r\n    bytesArray.push(serializeLPList(this.postConditions));\r\n    bytesArray.push(serializePayload(this.payload));\r\n\r\n    return concatArray(bytesArray);\r\n  }\r\n}\r\n\r\n/**\r\n * @param data Uint8Array or hex string\r\n */\r\nexport function deserializeTransaction(data: BytesReader | Uint8Array | string) {\r\n  let bytesReader: BytesReader;\r\n  if (typeof data === 'string') {\r\n    if (data.slice(0, 2).toLowerCase() === '0x') {\r\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\r\n    } else {\r\n      bytesReader = new BytesReader(hexToBytes(data));\r\n    }\r\n  } else if (data instanceof Uint8Array) {\r\n    bytesReader = new BytesReader(data);\r\n  } else {\r\n    bytesReader = data;\r\n  }\r\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\r\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\r\n  });\r\n  const chainId = bytesReader.readUInt32BE();\r\n  const auth = deserializeAuthorization(bytesReader);\r\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\r\n    throw new Error(`Could not parse ${n} as AnchorMode`);\r\n  });\r\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\r\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\r\n  });\r\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\r\n  const payload = deserializePayload(bytesReader);\r\n\r\n  return new StacksTransaction(\r\n    version,\r\n    auth,\r\n    payload,\r\n    postConditions,\r\n    postConditionMode,\r\n    anchorMode,\r\n    chainId\r\n  );\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}