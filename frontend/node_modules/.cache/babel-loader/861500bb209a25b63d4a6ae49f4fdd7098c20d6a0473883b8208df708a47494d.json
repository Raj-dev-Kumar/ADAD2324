{"ast":null,"code":"import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { deserializeCV, serializeCV } from './clarity';\nexport { verify as verifySignature } from '@noble/secp256k1';\nexport const randomBytes = bytesLength => utils.randomBytes(bytesLength);\nexport const leftPadHex = hexString => hexString.length % 2 == 0 ? hexString : `0${hexString}`;\nexport const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');\nexport const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');\nexport const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? utf8ToBytes(string).length > maxLengthBytes : false;\nexport function cloneDeep(obj) {\n  return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n  const clone = cloneDeep(obj);\n  delete clone[prop];\n  return clone;\n}\nexport const txidFromData = data => {\n  return bytesToHex(sha512_256(data));\n};\nexport const hash160 = input => {\n  return ripemd160(sha256(input));\n};\nexport const hashP2PKH = input => {\n  return bytesToHex(hash160(input));\n};\nexport const hashP2WPKH = input => {\n  const keyHash = hash160(input);\n  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport const hashP2SH = (numSigs, pubKeys) => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n  const bytesArray = [];\n  bytesArray.push(80 + numSigs);\n  pubKeys.forEach(pubKey => {\n    bytesArray.push(pubKey.length);\n    bytesArray.push(pubKey);\n  });\n  bytesArray.push(80 + pubKeys.length);\n  bytesArray.push(174);\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport const hashP2WSH = (numSigs, pubKeys) => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n  const scriptArray = [];\n  scriptArray.push(80 + numSigs);\n  pubKeys.forEach(pubKey => {\n    scriptArray.push(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  scriptArray.push(80 + pubKeys.length);\n  scriptArray.push(174);\n  const script = concatArray(scriptArray);\n  const digest = sha256(script);\n  const bytesArray = [];\n  bytesArray.push(0);\n  bytesArray.push(digest.length);\n  bytesArray.push(digest);\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport function isClarityName(name) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\nexport function cvToHex(cv) {\n  const serialized = serializeCV(cv);\n  return `0x${bytesToHex(serialized)}`;\n}\nexport function hexToCV(hex) {\n  return deserializeCV(hex);\n}\nexport const parseReadOnlyResponse = response => {\n  if (response.okay) return hexToCV(response.result);\n  throw new Error(response.cause);\n};\nexport const validateStacksAddress = stacksAddress => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexport const validateTxId = txid => {\n  if (txid === 'success') return true;\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};","map":{"version":3,"names":["ripemd160","sha256","sha512_256","utils","bytesToHex","concatArray","concatBytes","utf8ToBytes","with0x","c32addressDecode","lodashCloneDeep","deserializeCV","serializeCV","verify","verifySignature","randomBytes","bytesLength","leftPadHex","hexString","length","leftPadHexToLength","padStart","rightPadHexToLength","padEnd","exceedsMaxLengthBytes","string","maxLengthBytes","cloneDeep","obj","omit","prop","clone","txidFromData","data","hash160","input","hashP2PKH","hashP2WPKH","keyHash","redeemScript","Uint8Array","redeemScriptHash","hashP2SH","numSigs","pubKeys","Error","bytesArray","push","forEach","pubKey","hashP2WSH","scriptArray","script","digest","isClarityName","name","regex","test","cvToHex","cv","serialized","hexToCV","hex","parseReadOnlyResponse","response","okay","result","cause","validateStacksAddress","stacksAddress","e","validateTxId","txid","value","toLowerCase","BigInt","toString"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\utils.ts"],"sourcesContent":["import { ripemd160 } from '@noble/hashes/ripemd160';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { sha512_256 } from '@noble/hashes/sha512';\r\nimport { utils } from '@noble/secp256k1';\r\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\r\nimport { c32addressDecode } from 'c32check';\r\nimport lodashCloneDeep from 'lodash.clonedeep';\r\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\r\n\r\n// Export verify as utility method for signature verification\r\nexport { verify as verifySignature } from '@noble/secp256k1';\r\n\r\n/**\r\n * Use utils.randomBytes to replace randombytes dependency\r\n * Generates random bytes of given length\r\n * @param {number} bytesLength an optional bytes length, default is 32 bytes\r\n */\r\nexport const randomBytes = (bytesLength?: number): Uint8Array => utils.randomBytes(bytesLength);\r\n\r\nexport const leftPadHex = (hexString: string): string =>\r\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\r\n\r\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\r\n  hexString.padStart(length, '0');\r\n\r\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\r\n  hexString.padEnd(length, '0');\r\n\r\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\r\n  string ? utf8ToBytes(string).length > maxLengthBytes : false;\r\n\r\nexport function cloneDeep<T>(obj: T): T {\r\n  return lodashCloneDeep(obj);\r\n}\r\n\r\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\r\n  const clone = cloneDeep(obj);\r\n  // @ts-expect-error\r\n  delete clone[prop];\r\n  return clone;\r\n}\r\n\r\nexport const txidFromData = (data: Uint8Array): string => {\r\n  return bytesToHex(sha512_256(data));\r\n};\r\n\r\nexport const hash160 = (input: Uint8Array): Uint8Array => {\r\n  return ripemd160(sha256(input));\r\n};\r\n\r\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\r\n// single-sig address (p2pkh)\r\nexport const hashP2PKH = (input: Uint8Array): string => {\r\n  return bytesToHex(hash160(input));\r\n};\r\n\r\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\r\n// single-sig address over p2sh (p2h-p2wpkh)\r\nexport const hashP2WPKH = (input: Uint8Array): string => {\r\n  const keyHash = hash160(input);\r\n  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\r\n  const redeemScriptHash = hash160(redeemScript);\r\n  return bytesToHex(redeemScriptHash);\r\n};\r\n\r\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\r\n// multi-sig address (p2sh)\r\nexport const hashP2SH = (numSigs: number, pubKeys: Uint8Array[]): string => {\r\n  if (numSigs > 15 || pubKeys.length > 15) {\r\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\r\n  }\r\n\r\n  // construct P2SH script\r\n  const bytesArray = [];\r\n  // OP_n\r\n  bytesArray.push(80 + numSigs);\r\n  // public keys prepended by their length\r\n  pubKeys.forEach(pubKey => {\r\n    bytesArray.push(pubKey.length);\r\n    bytesArray.push(pubKey);\r\n  });\r\n  // OP_m\r\n  bytesArray.push(80 + pubKeys.length);\r\n  // OP_CHECKMULTISIG\r\n  bytesArray.push(174);\r\n\r\n  const redeemScript = concatArray(bytesArray);\r\n  const redeemScriptHash = hash160(redeemScript);\r\n  return bytesToHex(redeemScriptHash);\r\n};\r\n\r\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\r\n// multisig address over p2sh (p2sh-p2wsh)\r\nexport const hashP2WSH = (numSigs: number, pubKeys: Uint8Array[]): string => {\r\n  if (numSigs > 15 || pubKeys.length > 15) {\r\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\r\n  }\r\n\r\n  // construct P2SH script\r\n  const scriptArray = [];\r\n  // OP_n\r\n  scriptArray.push(80 + numSigs);\r\n  // public keys prepended by their length\r\n  pubKeys.forEach(pubKey => {\r\n    scriptArray.push(pubKey.length);\r\n    scriptArray.push(pubKey);\r\n  });\r\n  // OP_m\r\n  scriptArray.push(80 + pubKeys.length);\r\n  // OP_CHECKMULTISIG\r\n  scriptArray.push(174);\r\n\r\n  const script = concatArray(scriptArray);\r\n  const digest = sha256(script);\r\n\r\n  const bytesArray = [];\r\n  bytesArray.push(0);\r\n  bytesArray.push(digest.length);\r\n  bytesArray.push(digest);\r\n\r\n  const redeemScript = concatArray(bytesArray);\r\n  const redeemScriptHash = hash160(redeemScript);\r\n  return bytesToHex(redeemScriptHash);\r\n};\r\n\r\nexport function isClarityName(name: string) {\r\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\r\n  return regex.test(name) && name.length < 128;\r\n}\r\n\r\n/**\r\n * Converts a clarity value to a hex encoded string with `0x` prefix\r\n * @param {ClarityValue} cv  - the clarity value to convert\r\n */\r\nexport function cvToHex(cv: ClarityValue) {\r\n  const serialized = serializeCV(cv);\r\n  return `0x${bytesToHex(serialized)}`;\r\n}\r\n\r\n/**\r\n * Converts a hex encoded string to a clarity value\r\n * @param {string} hex - the hex encoded string with or without `0x` prefix\r\n */\r\nexport function hexToCV(hex: string) {\r\n  return deserializeCV(hex);\r\n}\r\n/**\r\n * Read only function response object\r\n *\r\n * @param {Boolean} okay - the status of the response\r\n * @param {string} result - serialized hex clarity value\r\n */\r\n\r\nexport interface ReadOnlyFunctionSuccessResponse {\r\n  okay: true;\r\n  result: string;\r\n}\r\n\r\nexport interface ReadOnlyFunctionErrorResponse {\r\n  okay: false;\r\n  cause: string;\r\n}\r\n\r\nexport type ReadOnlyFunctionResponse =\r\n  | ReadOnlyFunctionSuccessResponse\r\n  | ReadOnlyFunctionErrorResponse;\r\n\r\n/**\r\n * Converts the response of a read-only function call into its Clarity Value\r\n * @param param\r\n */\r\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\r\n  if (response.okay) return hexToCV(response.result);\r\n  throw new Error(response.cause);\r\n};\r\n\r\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\r\n  try {\r\n    c32addressDecode(stacksAddress);\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const validateTxId = (txid: string): boolean => {\r\n  if (txid === 'success') return true; // Bypass fetchMock tests // todo: move this line into mocks in test files\r\n  const value = with0x(txid).toLowerCase();\r\n  if (value.length !== 66) return false;\r\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\r\n};\r\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,UAAU,EAAEC,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,MAAM,QAAQ,gBAAgB;AAC1F,SAASC,gBAAgB,QAAQ,UAAU;AAC3C,OAAOC,eAAe,MAAM,kBAAkB;AAC9C,SAAuBC,aAAa,EAAEC,WAAW,QAAQ,WAAW;AAGpE,SAASC,MAAM,IAAIC,eAAe,QAAQ,kBAAkB;AAO5D,OAAO,MAAMC,WAAW,GAAIC,WAAoB,IAAiBb,KAAK,CAACY,WAAW,CAACC,WAAW,CAAC;AAE/F,OAAO,MAAMC,UAAU,GAAIC,SAAiB,IAC1CA,SAAS,CAACC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAGD,SAAS,GAAG,IAAIA,SAAS,EAAE;AAEzD,OAAO,MAAME,kBAAkB,GAAGA,CAACF,SAAiB,EAAEC,MAAc,KAClED,SAAS,CAACG,QAAQ,CAACF,MAAM,EAAE,GAAG,CAAC;AAEjC,OAAO,MAAMG,mBAAmB,GAAGA,CAACJ,SAAiB,EAAEC,MAAc,KACnED,SAAS,CAACK,MAAM,CAACJ,MAAM,EAAE,GAAG,CAAC;AAE/B,OAAO,MAAMK,qBAAqB,GAAGA,CAACC,MAAc,EAAEC,cAAsB,KAC1ED,MAAM,GAAGlB,WAAW,CAACkB,MAAM,CAAC,CAACN,MAAM,GAAGO,cAAc,GAAG,KAAK;AAE9D,OAAM,SAAUC,SAASA,CAAIC,GAAM;EACjC,OAAOlB,eAAe,CAACkB,GAAG,CAAC;AAC7B;AAEA,OAAM,SAAUC,IAAIA,CAAyBD,GAAM,EAAEE,IAAO;EAC1D,MAAMC,KAAK,GAAGJ,SAAS,CAACC,GAAG,CAAC;EAE5B,OAAOG,KAAK,CAACD,IAAI,CAAC;EAClB,OAAOC,KAAK;AACd;AAEA,OAAO,MAAMC,YAAY,GAAIC,IAAgB,IAAY;EACvD,OAAO7B,UAAU,CAACF,UAAU,CAAC+B,IAAI,CAAC,CAAC;AACrC,CAAC;AAED,OAAO,MAAMC,OAAO,GAAIC,KAAiB,IAAgB;EACvD,OAAOnC,SAAS,CAACC,MAAM,CAACkC,KAAK,CAAC,CAAC;AACjC,CAAC;AAID,OAAO,MAAMC,SAAS,GAAID,KAAiB,IAAY;EACrD,OAAO/B,UAAU,CAAC8B,OAAO,CAACC,KAAK,CAAC,CAAC;AACnC,CAAC;AAID,OAAO,MAAME,UAAU,GAAIF,KAAiB,IAAY;EACtD,MAAMG,OAAO,GAAGJ,OAAO,CAACC,KAAK,CAAC;EAC9B,MAAMI,YAAY,GAAGjC,WAAW,CAAC,IAAIkC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAIA,UAAU,CAAC,CAACF,OAAO,CAACnB,MAAM,CAAC,CAAC,EAAEmB,OAAO,CAAC;EAChG,MAAMG,gBAAgB,GAAGP,OAAO,CAACK,YAAY,CAAC;EAC9C,OAAOnC,UAAU,CAACqC,gBAAgB,CAAC;AACrC,CAAC;AAID,OAAO,MAAMC,QAAQ,GAAGA,CAACC,OAAe,EAAEC,OAAqB,KAAY;EACzE,IAAID,OAAO,GAAG,EAAE,IAAIC,OAAO,CAACzB,MAAM,GAAG,EAAE,EAAE;IACvC,MAAM0B,KAAK,CAAC,6DAA6D,CAAC;;EAI5E,MAAMC,UAAU,GAAG,EAAE;EAErBA,UAAU,CAACC,IAAI,CAAC,EAAE,GAAGJ,OAAO,CAAC;EAE7BC,OAAO,CAACI,OAAO,CAACC,MAAM,IAAG;IACvBH,UAAU,CAACC,IAAI,CAACE,MAAM,CAAC9B,MAAM,CAAC;IAC9B2B,UAAU,CAACC,IAAI,CAACE,MAAM,CAAC;EACzB,CAAC,CAAC;EAEFH,UAAU,CAACC,IAAI,CAAC,EAAE,GAAGH,OAAO,CAACzB,MAAM,CAAC;EAEpC2B,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC;EAEpB,MAAMR,YAAY,GAAGlC,WAAW,CAACyC,UAAU,CAAC;EAC5C,MAAML,gBAAgB,GAAGP,OAAO,CAACK,YAAY,CAAC;EAC9C,OAAOnC,UAAU,CAACqC,gBAAgB,CAAC;AACrC,CAAC;AAID,OAAO,MAAMS,SAAS,GAAGA,CAACP,OAAe,EAAEC,OAAqB,KAAY;EAC1E,IAAID,OAAO,GAAG,EAAE,IAAIC,OAAO,CAACzB,MAAM,GAAG,EAAE,EAAE;IACvC,MAAM0B,KAAK,CAAC,8DAA8D,CAAC;;EAI7E,MAAMM,WAAW,GAAG,EAAE;EAEtBA,WAAW,CAACJ,IAAI,CAAC,EAAE,GAAGJ,OAAO,CAAC;EAE9BC,OAAO,CAACI,OAAO,CAACC,MAAM,IAAG;IACvBE,WAAW,CAACJ,IAAI,CAACE,MAAM,CAAC9B,MAAM,CAAC;IAC/BgC,WAAW,CAACJ,IAAI,CAACE,MAAM,CAAC;EAC1B,CAAC,CAAC;EAEFE,WAAW,CAACJ,IAAI,CAAC,EAAE,GAAGH,OAAO,CAACzB,MAAM,CAAC;EAErCgC,WAAW,CAACJ,IAAI,CAAC,GAAG,CAAC;EAErB,MAAMK,MAAM,GAAG/C,WAAW,CAAC8C,WAAW,CAAC;EACvC,MAAME,MAAM,GAAGpD,MAAM,CAACmD,MAAM,CAAC;EAE7B,MAAMN,UAAU,GAAG,EAAE;EACrBA,UAAU,CAACC,IAAI,CAAC,CAAC,CAAC;EAClBD,UAAU,CAACC,IAAI,CAACM,MAAM,CAAClC,MAAM,CAAC;EAC9B2B,UAAU,CAACC,IAAI,CAACM,MAAM,CAAC;EAEvB,MAAMd,YAAY,GAAGlC,WAAW,CAACyC,UAAU,CAAC;EAC5C,MAAML,gBAAgB,GAAGP,OAAO,CAACK,YAAY,CAAC;EAC9C,OAAOnC,UAAU,CAACqC,gBAAgB,CAAC;AACrC,CAAC;AAED,OAAM,SAAUa,aAAaA,CAACC,IAAY;EACxC,MAAMC,KAAK,GAAG,0DAA0D;EACxE,OAAOA,KAAK,CAACC,IAAI,CAACF,IAAI,CAAC,IAAIA,IAAI,CAACpC,MAAM,GAAG,GAAG;AAC9C;AAMA,OAAM,SAAUuC,OAAOA,CAACC,EAAgB;EACtC,MAAMC,UAAU,GAAGhD,WAAW,CAAC+C,EAAE,CAAC;EAClC,OAAO,KAAKvD,UAAU,CAACwD,UAAU,CAAC,EAAE;AACtC;AAMA,OAAM,SAAUC,OAAOA,CAACC,GAAW;EACjC,OAAOnD,aAAa,CAACmD,GAAG,CAAC;AAC3B;AA0BA,OAAO,MAAMC,qBAAqB,GAAIC,QAAkC,IAAkB;EACxF,IAAIA,QAAQ,CAACC,IAAI,EAAE,OAAOJ,OAAO,CAACG,QAAQ,CAACE,MAAM,CAAC;EAClD,MAAM,IAAIrB,KAAK,CAACmB,QAAQ,CAACG,KAAK,CAAC;AACjC,CAAC;AAED,OAAO,MAAMC,qBAAqB,GAAIC,aAAqB,IAAa;EACtE,IAAI;IACF5D,gBAAgB,CAAC4D,aAAa,CAAC;IAC/B,OAAO,IAAI;GACZ,CAAC,OAAOC,CAAC,EAAE;IACV,OAAO,KAAK;;AAEhB,CAAC;AAED,OAAO,MAAMC,YAAY,GAAIC,IAAY,IAAa;EACpD,IAAIA,IAAI,KAAK,SAAS,EAAE,OAAO,IAAI;EACnC,MAAMC,KAAK,GAAGjE,MAAM,CAACgE,IAAI,CAAC,CAACE,WAAW,EAAE;EACxC,IAAID,KAAK,CAACtD,MAAM,KAAK,EAAE,EAAE,OAAO,KAAK;EACrC,OAAOX,MAAM,CAACmE,MAAM,CAACF,KAAK,CAAC,CAACG,QAAQ,CAAC,EAAE,CAAC,CAACvD,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,KAAKoD,KAAK;AACvE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}