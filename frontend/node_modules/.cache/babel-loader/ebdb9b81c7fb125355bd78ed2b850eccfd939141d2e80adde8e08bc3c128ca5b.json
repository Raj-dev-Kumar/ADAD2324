{"ast":null,"code":"import { bytesToHex, bytesToUtf8, getGlobalObject, hexToBytes, makeUUID4, nextMonth, utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, makeECPrivateKey, publicKeyToBtcAddress } from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\nconst VERSION = '1.4.0';\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport const makeAuthRequest = makeAuthRequestToken;\nexport function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI, scopes = DEFAULT_SCOPE.slice(), appDomain, expiresAt = nextMonth().getTime(), extraParams = {}) {\n  const getWindowOrigin = paramName => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location?.origin;\n  };\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\nexport async function makeAuthResponse(privateKey, profile = {}, metadata, coreToken = null, appPrivateKey = null, expiresAt = nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null, appPrivateKeyFromWalletSalt = null) {\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {}\n  const payload = Object.assign({}, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    appPrivateKeyFromWalletSalt,\n    profile,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":{"version":3,"names":["bytesToHex","bytesToUtf8","getGlobalObject","hexToBytes","makeUUID4","nextMonth","utf8ToBytes","decryptECIES","encryptECIES","makeECPrivateKey","publicKeyToBtcAddress","SECP256K1Client","TokenSigner","DEFAULT_SCOPE","makeDIDFromAddress","VERSION","generateTransitKey","transitKey","makeAuthRequest","makeAuthRequestToken","transitPrivateKey","redirectURI","manifestURI","scopes","slice","appDomain","expiresAt","getTime","extraParams","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","origin","payload","Object","assign","jti","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","derivePublicKey","address","tokenSigner","token","sign","encryptPrivateKey","privateKey","encryptedObj","encryptedJSON","JSON","stringify","decryptPrivateKey","hexedEncrypted","unhexedString","parse","decrypted","Error","makeAuthResponse","profile","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","appPrivateKeyFromWalletSalt","privateKeyPayload","coreTokenPayload","additionalProperties","undefined","email","profile_url","profileUrl","private_key","core_token"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\auth\\src\\messages.ts"],"sourcesContent":["import {\r\n  bytesToHex,\r\n  bytesToUtf8,\r\n  getGlobalObject,\r\n  hexToBytes,\r\n  makeUUID4,\r\n  nextMonth,\r\n  utf8ToBytes,\r\n} from '@stacks/common';\r\nimport {\r\n  decryptECIES,\r\n  encryptECIES,\r\n  makeECPrivateKey,\r\n  publicKeyToBtcAddress,\r\n} from '@stacks/encryption';\r\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\r\nimport { AuthScope, DEFAULT_SCOPE } from './constants';\r\nimport { makeDIDFromAddress } from './dids';\r\n\r\nconst VERSION = '1.4.0';\r\n\r\ntype AuthMetadata = {\r\n  email?: string;\r\n  profileUrl?: string;\r\n};\r\n\r\n/**\r\n * Generates a ECDSA keypair to\r\n * use as the ephemeral app transit private key\r\n * @param {SessionData} session - session object in which key will be stored\r\n * @return {String} the hex encoded private key\r\n * @private\r\n * @ignore\r\n */\r\nexport function generateTransitKey() {\r\n  const transitKey = makeECPrivateKey();\r\n  return transitKey;\r\n}\r\n\r\n/** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\r\nexport const makeAuthRequest = makeAuthRequestToken;\r\n\r\n/**\r\n * Generates an authentication request that can be sent to the Blockstack\r\n * browser for the user to approve sign in. This authentication request can\r\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\r\n * method.\r\n *\r\n * *Note: This method should only be used if you want to roll your own authentication\r\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\r\n * under the hood.*\r\n *\r\n * @param  {String} transitPrivateKey - hex encoded transit private key\r\n * @param {String} redirectURI - location to redirect user to after sign in approval\r\n * @param {String} manifestURI - location of this app's manifest file\r\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\r\n * @param {String} appDomain - the origin of this app\r\n * @param {Number} expiresAt - the time at which this request is no longer valid\r\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\r\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\r\n * by special authenticators.\r\n * @return {String} the authentication request\r\n */\r\nexport function makeAuthRequestToken(\r\n  transitPrivateKey: string,\r\n  redirectURI?: string,\r\n  manifestURI?: string,\r\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\r\n  appDomain?: string,\r\n  expiresAt: number = nextMonth().getTime(),\r\n  extraParams: any = {}\r\n): string {\r\n  const getWindowOrigin = (paramName: string) => {\r\n    const location = getGlobalObject('location', {\r\n      throwIfUnavailable: true,\r\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\r\n    });\r\n    return location?.origin;\r\n  };\r\n\r\n  if (!redirectURI) {\r\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\r\n  }\r\n  if (!manifestURI) {\r\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\r\n  }\r\n  if (!appDomain) {\r\n    appDomain = getWindowOrigin('appDomain');\r\n  }\r\n\r\n  /* Create the payload */\r\n  const payload = Object.assign({}, extraParams, {\r\n    jti: makeUUID4(),\r\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\r\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\r\n    iss: null,\r\n    public_keys: [],\r\n    domain_name: appDomain,\r\n    manifest_uri: manifestURI,\r\n    redirect_uri: redirectURI,\r\n    version: VERSION,\r\n    do_not_include_profile: true,\r\n    supports_hub_url: true,\r\n    scopes,\r\n  });\r\n\r\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\r\n\r\n  /* Convert the private key to a public key to an issuer */\r\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\r\n  payload.public_keys = [publicKey];\r\n  const address = publicKeyToBtcAddress(publicKey);\r\n  payload.iss = makeDIDFromAddress(address);\r\n\r\n  /* Sign and return the token */\r\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\r\n  const token = tokenSigner.sign(payload);\r\n\r\n  return token;\r\n}\r\n\r\n/**\r\n * Encrypts the private key for decryption by the given\r\n * public key.\r\n * @param  {String} publicKey  [description]\r\n * @param  {String} privateKey [description]\r\n * @return {String} hex encoded ciphertext\r\n * @private\r\n * @ignore\r\n */\r\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\r\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\r\n  const encryptedJSON = JSON.stringify(encryptedObj);\r\n  return bytesToHex(utf8ToBytes(encryptedJSON));\r\n}\r\n\r\n/**\r\n * Decrypts the hex encrypted private key\r\n * @param  {String} privateKey  the private key corresponding to the public\r\n * key for which the ciphertext was encrypted\r\n * @param  {String} hexedEncrypted the ciphertext\r\n * @return {String}  the decrypted private key\r\n * @throws {Error} if unable to decrypt\r\n *\r\n * @private\r\n * @ignore\r\n */\r\nexport async function decryptPrivateKey(\r\n  privateKey: string,\r\n  hexedEncrypted: string\r\n): Promise<string | null> {\r\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\r\n  const encryptedObj = JSON.parse(unhexedString);\r\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\r\n  if (typeof decrypted !== 'string') {\r\n    throw new Error('Unable to correctly decrypt private key');\r\n  } else {\r\n    return decrypted;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a signed authentication response token for an app. This\r\n * token is sent back to apps which use contents to access the\r\n * resources and data requested by the app.\r\n *\r\n * @param  {String} privateKey the identity key of the Blockstack ID generating\r\n * the authentication response\r\n * @param  {Object} profile the profile object for the Blockstack ID\r\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\r\n * response including `email` if requested and available and a URL to the profile\r\n * @param  {String} coreToken core session token when responding to a legacy auth request\r\n * or `null` for current direct to gaia authentication requests\r\n * @param  {String} appPrivateKey the application private key. This private key is\r\n * unique and specific for every Blockstack ID and application combination.\r\n * @param  {Number} expiresAt an integer in the same format as\r\n * `new Date().getTime()`, milliseconds since the Unix epoch\r\n * @param {String} transitPublicKey the public key provide by the app\r\n * in its authentication request with which secrets will be encrypted\r\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\r\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\r\n * @param {String} associationToken JWT that binds the app key to the identity key\r\n * @return {String} signed and encoded authentication response token\r\n * @private\r\n * @ignore\r\n */\r\nexport async function makeAuthResponse(\r\n  privateKey: string,\r\n  // eslint-disable-next-line @typescript-eslint/ban-types\r\n  profile: {} = {},\r\n  metadata: AuthMetadata | null,\r\n  coreToken: string | null = null,\r\n  appPrivateKey: string | null = null,\r\n  expiresAt: number = nextMonth().getTime(),\r\n  transitPublicKey: string | null = null,\r\n  hubUrl: string | null = null,\r\n  blockstackAPIUrl: string | null = null,\r\n  associationToken: string | null = null,\r\n  appPrivateKeyFromWalletSalt: string | null = null\r\n): Promise<string> {\r\n  /* Convert the private key to a public key to an issuer */\r\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\r\n  const address = publicKeyToBtcAddress(publicKey);\r\n\r\n  /* See if we should encrypt with the transit key */\r\n  let privateKeyPayload = appPrivateKey;\r\n  let coreTokenPayload = coreToken;\r\n  let additionalProperties = {};\r\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\r\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\r\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\r\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\r\n      if (coreToken !== undefined && coreToken !== null) {\r\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\r\n      }\r\n    }\r\n    additionalProperties = {\r\n      email: metadata?.email ? metadata.email : null,\r\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\r\n      hubUrl,\r\n      blockstackAPIUrl,\r\n      associationToken,\r\n      version: VERSION,\r\n    };\r\n  } else {\r\n    // Logger.info('blockstack.js: generating legacy auth response')\r\n  }\r\n\r\n  /* Create the payload */\r\n  const payload = Object.assign(\r\n    {},\r\n    {\r\n      jti: makeUUID4(),\r\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\r\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\r\n      iss: makeDIDFromAddress(address),\r\n      private_key: privateKeyPayload,\r\n      public_keys: [publicKey],\r\n      appPrivateKeyFromWalletSalt,\r\n      profile,\r\n      core_token: coreTokenPayload,\r\n    },\r\n    additionalProperties\r\n  );\r\n\r\n  /* Sign and return the token */\r\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\r\n  return tokenSigner.sign(payload);\r\n}\r\n"],"mappings":"AAAA,SACEA,UAAU,EACVC,WAAW,EACXC,eAAe,EACfC,UAAU,EACVC,SAAS,EACTC,SAAS,EACTC,WAAW,QACN,gBAAgB;AACvB,SACEC,YAAY,EACZC,YAAY,EACZC,gBAAgB,EAChBC,qBAAqB,QAChB,oBAAoB;AAC3B,SAASC,eAAe,EAAEC,WAAW,QAAQ,YAAY;AACzD,SAAoBC,aAAa,QAAQ,aAAa;AACtD,SAASC,kBAAkB,QAAQ,QAAQ;AAE3C,MAAMC,OAAO,GAAG,OAAO;AAevB,OAAM,SAAUC,kBAAkBA,CAAA;EAChC,MAAMC,UAAU,GAAGR,gBAAgB,EAAE;EACrC,OAAOQ,UAAU;AACnB;AAGA,OAAO,MAAMC,eAAe,GAAGC,oBAAoB;AAuBnD,OAAM,SAAUA,oBAAoBA,CAClCC,iBAAyB,EACzBC,WAAoB,EACpBC,WAAoB,EACpBC,MAAA,GAAiCV,aAAa,CAACW,KAAK,EAAE,EACtDC,SAAkB,EAClBC,SAAA,GAAoBrB,SAAS,EAAE,CAACsB,OAAO,EAAE,EACzCC,WAAA,GAAmB,EAAE;EAErB,MAAMC,eAAe,GAAIC,SAAiB,IAAI;IAC5C,MAAMC,QAAQ,GAAG7B,eAAe,CAAC,UAAU,EAAE;MAC3C8B,kBAAkB,EAAE,IAAI;MACxBC,SAAS,EAAE,oBAAoBH,SAAS;KACzC,CAAC;IACF,OAAOC,QAAQ,EAAEG,MAAM;EACzB,CAAC;EAED,IAAI,CAACb,WAAW,EAAE;IAChBA,WAAW,GAAG,GAAGQ,eAAe,CAAC,aAAa,CAAC,GAAG;;EAEpD,IAAI,CAACP,WAAW,EAAE;IAChBA,WAAW,GAAG,GAAGO,eAAe,CAAC,aAAa,CAAC,gBAAgB;;EAEjE,IAAI,CAACJ,SAAS,EAAE;IACdA,SAAS,GAAGI,eAAe,CAAC,WAAW,CAAC;;EAI1C,MAAMM,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAET,WAAW,EAAE;IAC7CU,GAAG,EAAElC,SAAS,EAAE;IAChBmC,GAAG,EAAEC,IAAI,CAACC,KAAK,CAAC,IAAIC,IAAI,EAAE,CAACf,OAAO,EAAE,GAAG,IAAI,CAAC;IAC5CgB,GAAG,EAAEH,IAAI,CAACC,KAAK,CAACf,SAAS,GAAG,IAAI,CAAC;IACjCkB,GAAG,EAAE,IAAI;IACTC,WAAW,EAAE,EAAE;IACfC,WAAW,EAAErB,SAAS;IACtBsB,YAAY,EAAEzB,WAAW;IACzB0B,YAAY,EAAE3B,WAAW;IACzB4B,OAAO,EAAElC,OAAO;IAChBmC,sBAAsB,EAAE,IAAI;IAC5BC,gBAAgB,EAAE,IAAI;IACtB5B;GACD,CAAC;EAKF,MAAM6B,SAAS,GAAGzC,eAAe,CAAC0C,eAAe,CAACjC,iBAAiB,CAAC;EACpEe,OAAO,CAACU,WAAW,GAAG,CAACO,SAAS,CAAC;EACjC,MAAME,OAAO,GAAG5C,qBAAqB,CAAC0C,SAAS,CAAC;EAChDjB,OAAO,CAACS,GAAG,GAAG9B,kBAAkB,CAACwC,OAAO,CAAC;EAGzC,MAAMC,WAAW,GAAG,IAAI3C,WAAW,CAAC,QAAQ,EAAEQ,iBAAiB,CAAC;EAChE,MAAMoC,KAAK,GAAGD,WAAW,CAACE,IAAI,CAACtB,OAAO,CAAC;EAEvC,OAAOqB,KAAK;AACd;AAWA,OAAO,eAAeE,iBAAiBA,CAACN,SAAiB,EAAEO,UAAkB;EAC3E,MAAMC,YAAY,GAAG,MAAMpD,YAAY,CAAC4C,SAAS,EAAE9C,WAAW,CAACqD,UAAU,CAAC,EAAE,IAAI,CAAC;EACjF,MAAME,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACH,YAAY,CAAC;EAClD,OAAO5D,UAAU,CAACM,WAAW,CAACuD,aAAa,CAAC,CAAC;AAC/C;AAaA,OAAO,eAAeG,iBAAiBA,CACrCL,UAAkB,EAClBM,cAAsB;EAEtB,MAAMC,aAAa,GAAGjE,WAAW,CAACE,UAAU,CAAC8D,cAAc,CAAC,CAAC;EAC7D,MAAML,YAAY,GAAGE,IAAI,CAACK,KAAK,CAACD,aAAa,CAAC;EAC9C,MAAME,SAAS,GAAG,MAAM7D,YAAY,CAACoD,UAAU,EAAEC,YAAY,CAAC;EAC9D,IAAI,OAAOQ,SAAS,KAAK,QAAQ,EAAE;IACjC,MAAM,IAAIC,KAAK,CAAC,yCAAyC,CAAC;GAC3D,MAAM;IACL,OAAOD,SAAS;;AAEpB;AA2BA,OAAO,eAAeE,gBAAgBA,CACpCX,UAAkB,EAElBY,OAAA,GAAc,EAAE,EAChBC,QAA6B,EAC7BC,SAAA,GAA2B,IAAI,EAC/BC,aAAA,GAA+B,IAAI,EACnChD,SAAA,GAAoBrB,SAAS,EAAE,CAACsB,OAAO,EAAE,EACzCgD,gBAAA,GAAkC,IAAI,EACtCC,MAAA,GAAwB,IAAI,EAC5BC,gBAAA,GAAkC,IAAI,EACtCC,gBAAA,GAAkC,IAAI,EACtCC,2BAAA,GAA6C,IAAI;EAGjD,MAAM3B,SAAS,GAAGzC,eAAe,CAAC0C,eAAe,CAACM,UAAU,CAAC;EAC7D,MAAML,OAAO,GAAG5C,qBAAqB,CAAC0C,SAAS,CAAC;EAGhD,IAAI4B,iBAAiB,GAAGN,aAAa;EACrC,IAAIO,gBAAgB,GAAGR,SAAS;EAChC,IAAIS,oBAAoB,GAAG,EAAE;EAC7B,IAAIR,aAAa,KAAKS,SAAS,IAAIT,aAAa,KAAK,IAAI,EAAE;IAEzD,IAAIC,gBAAgB,KAAKQ,SAAS,IAAIR,gBAAgB,KAAK,IAAI,EAAE;MAC/DK,iBAAiB,GAAG,MAAMtB,iBAAiB,CAACiB,gBAAgB,EAAED,aAAa,CAAC;MAC5E,IAAID,SAAS,KAAKU,SAAS,IAAIV,SAAS,KAAK,IAAI,EAAE;QACjDQ,gBAAgB,GAAG,MAAMvB,iBAAiB,CAACiB,gBAAgB,EAAEF,SAAS,CAAC;;;IAG3ES,oBAAoB,GAAG;MACrBE,KAAK,EAAEZ,QAAQ,EAAEY,KAAK,GAAGZ,QAAQ,CAACY,KAAK,GAAG,IAAI;MAC9CC,WAAW,EAAEb,QAAQ,EAAEc,UAAU,GAAGd,QAAQ,CAACc,UAAU,GAAG,IAAI;MAC9DV,MAAM;MACNC,gBAAgB;MAChBC,gBAAgB;MAChB7B,OAAO,EAAElC;KACV;GACF,MAAM,C;EAKP,MAAMoB,OAAO,GAAGC,MAAM,CAACC,MAAM,CAC3B,EAAE,EACF;IACEC,GAAG,EAAElC,SAAS,EAAE;IAChBmC,GAAG,EAAEC,IAAI,CAACC,KAAK,CAAC,IAAIC,IAAI,EAAE,CAACf,OAAO,EAAE,GAAG,IAAI,CAAC;IAC5CgB,GAAG,EAAEH,IAAI,CAACC,KAAK,CAACf,SAAS,GAAG,IAAI,CAAC;IACjCkB,GAAG,EAAE9B,kBAAkB,CAACwC,OAAO,CAAC;IAChCiC,WAAW,EAAEP,iBAAiB;IAC9BnC,WAAW,EAAE,CAACO,SAAS,CAAC;IACxB2B,2BAA2B;IAC3BR,OAAO;IACPiB,UAAU,EAAEP;GACb,EACDC,oBAAoB,CACrB;EAGD,MAAM3B,WAAW,GAAG,IAAI3C,WAAW,CAAC,QAAQ,EAAE+C,UAAU,CAAC;EACzD,OAAOJ,WAAW,CAACE,IAAI,CAACtB,OAAO,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}