{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey, getSharedSecret, Point, Signature, signSync, utils, verify } from '@noble/secp256k1';\nimport { bigIntToBytes, bytesToHex, bytesToUtf8, concatBytes, FailedDecryptionError, hexToBigInt, hexToBytes, parseRecoverableSignatureVrs, signatureRsvToVrs, utf8ToBytes } from '@stacks/common';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport { createCipher } from './aesCipher';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { encodeMessage, hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nutils.hmacSha256Sync = (key, ...msgs) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport var InvalidPublicKeyReason;\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = await createCipher();\n  return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n}\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = await createCipher();\n  return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n}\nexport function hmacSha256(key, content) {\n  return hmac(sha256, key, content);\n}\nfunction equalsConstTime(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < a.length; i++) {\n    res |= a[i] ^ b[i];\n  }\n  return res === 0;\n}\nfunction sharedSecretToKeys(sharedSecret) {\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\nfunction isValidPublicKey(pub) {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  const firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n  try {\n    const point = Point.fromHex(pub);\n    point.assertValidity();\n    return {\n      result: true,\n      reason_data: null,\n      reason: null\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\nexport function getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBytesFromBN(bnInput) {\n  const result = bigIntToBytes(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte Uint8Array');\n  }\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  const shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  const ivLength = 32;\n  const ephemeralPKLength = 66;\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  const shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  const signatureLength = 144;\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  const {\n    payloadShell,\n    payloadValuesLength\n  } = getCipherObjectWrapper(opts);\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  let encodedCipherTextLength;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    const {\n      signedPayloadShell,\n      signedPayloadValuesLength\n    } = getSignedCipherObjectWrapper(payloadShell);\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n  const validity = isValidPublicKey(publicKey);\n  if (!validity.result) {\n    throw validity;\n  }\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const initializationVector = utils.randomBytes(16);\n  const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n  let cipherTextString;\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = fromByteArray(cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n  const result = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n  }\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const ivBytes = hexToBytes(cipherObject.iv);\n  let cipherTextBytes;\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBytes = hexToBytes(cipherObject.cipherText);\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBytes = toByteArray(cipherObject.cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = hexToBytes(cipherObject.mac);\n  if (!equalsConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\n  if (cipherObject.wasString) {\n    return bytesToUtf8(plainText);\n  }\n  return plainText;\n}\nexport function signECDSA(privateKey, content) {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBytes);\n  const signature = signSync(contentHash, privateKey);\n  return {\n    signature: bytesToHex(signature),\n    publicKey\n  };\n}\nexport function verifyECDSA(content, publicKey, signature) {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const contentHash = hashSha256Sync(contentBytes);\n  return verify(signature, contentHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignature({\n  signature,\n  message,\n  publicKey\n}) {\n  const {\n    r,\n    s\n  } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  const verificationResult = verify(sig, hashedMsg, publicKey, {\n    strict: false\n  });\n  if (verificationResult || typeof message !== 'string') return verificationResult;\n  const LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\n  const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\n  return verify(sig, legacyHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignatureRsv({\n  signature,\n  message,\n  publicKey\n}) {\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey\n  });\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","getSharedSecret","Point","Signature","signSync","utils","verify","bigIntToBytes","bytesToHex","bytesToUtf8","concatBytes","FailedDecryptionError","hexToBigInt","hexToBytes","parseRecoverableSignatureVrs","signatureRsvToVrs","utf8ToBytes","fromByteArray","toByteArray","createCipher","getPublicKeyFromPrivate","encodeMessage","hashMessage","hashSha256Sync","hashSha512Sync","getAesCbcOutputLength","getBase64OutputLength","hmacSha256Sync","key","msgs","h","create","forEach","msg","update","digest","InvalidPublicKeyReason","aes256CbcEncrypt","iv","plaintext","cipher","encrypt","aes256CbcDecrypt","ciphertext","decrypt","hmacSha256","content","equalsConstTime","a","b","length","res","i","sharedSecretToKeys","sharedSecret","hashedSecret","encryptionKey","slice","hmacKey","allHexChars","maybe","match","isValidPublicKey","pub","invalidFormat","result","reason_data","reason","InvalidFormat","invalidPoint","IsNotPoint","firstByte","point","fromHex","assertValidity","e","getHexFromBN","bnInput","hexOut","toString","padding","repeat","Error","getBytesFromBN","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","ivLength","ephemeralPKLength","macLength","payloadValuesLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signature","publicKey","signatureLength","publicKeyLength","signedPayloadValuesLength","signedPayloadShell","eciesGetJsonStringLength","cipherTextLength","contentLength","encodedCipherTextLength","sign","encryptECIES","validity","ephemeralPrivateKey","randomPrivateKey","ephemeralPublicKey","sharedKeys","initializationVector","randomBytes","macData","cipherTextString","decryptECIES","privateKey","cipherObject","ivBytes","cipherTextBytes","actualMac","expectedMac","plainText","signECDSA","contentBytes","contentHash","verifyECDSA","strict","verifyMessageSignature","message","r","s","sig","hashedMsg","verificationResult","LEGACY_PREFIX","legacyHash","verifyMessageSignatureRsv"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\encryption\\src\\ec.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport {\r\n  getPublicKey,\r\n  getSharedSecret,\r\n  Point,\r\n  Signature,\r\n  signSync,\r\n  utils,\r\n  verify,\r\n} from '@noble/secp256k1';\r\nimport {\r\n  bigIntToBytes,\r\n  bytesToHex,\r\n  bytesToUtf8,\r\n  concatBytes,\r\n  FailedDecryptionError,\r\n  hexToBigInt,\r\n  hexToBytes,\r\n  parseRecoverableSignatureVrs,\r\n  signatureRsvToVrs,\r\n  utf8ToBytes,\r\n} from '@stacks/common';\r\nimport { fromByteArray, toByteArray } from 'base64-js';\r\nimport { createCipher } from './aesCipher';\r\nimport { getPublicKeyFromPrivate } from './keys';\r\nimport { encodeMessage, hashMessage } from './messageSignature';\r\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\r\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\r\n\r\n/**\r\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\r\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\r\n * secp256k1.signSync is used within signECDSA in this file\r\n * secp256k1.signSync is used to maintain the semantics of signECDSA while migrating from elliptic lib\r\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\r\n */\r\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\r\n  const h = hmac.create(sha256, key);\r\n  msgs.forEach(msg => h.update(msg));\r\n  return h.digest();\r\n};\r\n\r\n/**\r\n * Controls how the encrypted data bytes will be encoded as a string in the JSON payload.\r\n * Options:\r\n *    `hex` -- the legacy default, file size increase 100% (2x).\r\n *    `base64` -- file size increased ~33%.\r\n * @ignore\r\n */\r\nexport type CipherTextEncoding = 'hex' | 'base64';\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport type CipherObject = {\r\n  iv: string;\r\n  ephemeralPK: string;\r\n  cipherText: string;\r\n  /** If undefined then hex encoding is used for the `cipherText` string. */\r\n  cipherTextEncoding?: CipherTextEncoding;\r\n  mac: string;\r\n  wasString: boolean;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport type SignedCipherObject = {\r\n  /** Hex encoded DER signature (up to 144 chars) */\r\n  signature: string;\r\n  /** Hex encoded public key (66 char length) */\r\n  publicKey: string;\r\n  /** The stringified json of a `CipherObject` */\r\n  cipherText: string;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport enum InvalidPublicKeyReason {\r\n  InvalidFormat = 'InvalidFormat',\r\n  IsNotPoint = 'IsNotPoint',\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport async function aes256CbcEncrypt(\r\n  iv: Uint8Array,\r\n  key: Uint8Array,\r\n  plaintext: Uint8Array\r\n): Promise<Uint8Array> {\r\n  const cipher = await createCipher();\r\n  return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nasync function aes256CbcDecrypt(\r\n  iv: Uint8Array,\r\n  key: Uint8Array,\r\n  ciphertext: Uint8Array\r\n): Promise<Uint8Array> {\r\n  const cipher = await createCipher();\r\n  return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport function hmacSha256(key: Uint8Array, content: Uint8Array): Uint8Array {\r\n  return hmac(sha256, key, content);\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction equalsConstTime(a: Uint8Array, b: Uint8Array) {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n  let res = 0;\r\n  for (let i = 0; i < a.length; i++) {\r\n    res |= a[i] ^ b[i];\r\n  }\r\n  return res === 0;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction sharedSecretToKeys(sharedSecret: Uint8Array): {\r\n  encryptionKey: Uint8Array;\r\n  hmacKey: Uint8Array;\r\n} {\r\n  // generate mac and encryption key from shared secret\r\n  const hashedSecret = hashSha512Sync(sharedSecret);\r\n  return {\r\n    encryptionKey: hashedSecret.slice(0, 32),\r\n    hmacKey: hashedSecret.slice(32),\r\n  };\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction allHexChars(maybe: string): boolean {\r\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction isValidPublicKey(pub: string): {\r\n  result: boolean;\r\n  reason: string | null;\r\n  reason_data: string | null;\r\n} {\r\n  const invalidFormat = {\r\n    result: false,\r\n    reason_data: 'Invalid public key format',\r\n    reason: InvalidPublicKeyReason.InvalidFormat,\r\n  };\r\n  const invalidPoint = {\r\n    result: false,\r\n    reason_data: 'Public key is not a point',\r\n    reason: InvalidPublicKeyReason.IsNotPoint,\r\n  };\r\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\r\n\r\n  const firstByte = pub.slice(0, 2);\r\n\r\n  // uncompressed public key\r\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\r\n\r\n  // compressed public key\r\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\r\n\r\n  if (!allHexChars(pub)) return invalidFormat;\r\n\r\n  try {\r\n    // Converts public key to Point\r\n    const point = Point.fromHex(pub);\r\n\r\n    // Verify point on curve is valid if it conforms to equation\r\n    // Validate the public key\r\n    // Throws: Point is not on elliptic curve if point is not on curve\r\n    point.assertValidity();\r\n\r\n    // Validation passed\r\n    return {\r\n      result: true,\r\n      reason_data: null,\r\n      reason: null,\r\n    };\r\n  } catch (e) {\r\n    return invalidPoint;\r\n  }\r\n}\r\n\r\n/**\r\n * Hex encodes a 32-byte bigint instance.\r\n * The result string is zero padded and always 64 characters in length.\r\n * @ignore\r\n */\r\nexport function getHexFromBN(bnInput: bigint): string {\r\n  const hexOut = bnInput.toString(16);\r\n  if (hexOut.length === 64) {\r\n    return hexOut;\r\n  } else if (hexOut.length < 64) {\r\n    // pad with leading zeros\r\n    // the padStart function would require node 9\r\n    const padding = '0'.repeat(64 - hexOut.length);\r\n    return `${padding}${hexOut}`;\r\n  } else {\r\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\r\n  }\r\n}\r\n\r\n/**\r\n * Converts to zero padded 32 bytes\r\n * @ignore\r\n */\r\nexport function getBytesFromBN(bnInput: bigint): Uint8Array {\r\n  // todo: remove method?\r\n  const result = bigIntToBytes(bnInput, 32);\r\n  if (result.byteLength !== 32) {\r\n    throw new Error('Failed to generate a 32-byte Uint8Array');\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get details about the JSON envelope size overhead for ciphertext payloads.\r\n * @ignore\r\n */\r\nexport function getCipherObjectWrapper(opts: {\r\n  wasString: boolean;\r\n  cipherTextEncoding: CipherTextEncoding;\r\n}): {\r\n  /** The stringified JSON string of an empty `CipherObject`. */\r\n  payloadShell: string;\r\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\r\n  payloadValuesLength: number;\r\n} {\r\n  // Placeholder structure of the ciphertext payload, used to determine the\r\n  // stringified JSON overhead length.\r\n  const shell: CipherObject = {\r\n    iv: '',\r\n    ephemeralPK: '',\r\n    mac: '',\r\n    cipherText: '',\r\n    wasString: !!opts.wasString,\r\n  };\r\n  if (opts.cipherTextEncoding === 'base64') {\r\n    shell.cipherTextEncoding = 'base64';\r\n  }\r\n  // Hex encoded 16 bytes.\r\n  const ivLength = 32;\r\n  // Hex encoded, compressed EC pubkey of 33 bytes.\r\n  const ephemeralPKLength = 66;\r\n  // Hex encoded 32 byte hmac-sha256.\r\n  const macLength = 64;\r\n  return {\r\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\r\n    payloadShell: JSON.stringify(shell),\r\n  };\r\n}\r\n\r\n/**\r\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\r\n * @param payloadShell - The JSON stringified empty `CipherObject`\r\n * @ignore\r\n */\r\nexport function getSignedCipherObjectWrapper(payloadShell: string): {\r\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\r\n  signedPayloadValuesLength: number;\r\n  /** Total string length of all the `SignedCipherObject` values\r\n   * that always have constant lengths */\r\n  signedPayloadShell: string;\r\n} {\r\n  // Placeholder structure of the signed ciphertext payload, used to determine the\r\n  // stringified JSON overhead length.\r\n  const shell: SignedCipherObject = {\r\n    signature: '',\r\n    publicKey: '',\r\n    cipherText: payloadShell,\r\n  };\r\n  // Hex encoded DER signature, up to 72 byte length.\r\n  const signatureLength = 144;\r\n  // Hex encoded 33 byte public key.\r\n  const publicKeyLength = 66;\r\n  return {\r\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\r\n    signedPayloadShell: JSON.stringify(shell),\r\n  };\r\n}\r\n\r\n/**\r\n * Fast function that determines the final ASCII string byte length of the\r\n * JSON stringified ECIES encrypted payload.\r\n * @ignore\r\n */\r\nexport function eciesGetJsonStringLength(opts: {\r\n  contentLength: number;\r\n  wasString: boolean;\r\n  sign: boolean;\r\n  cipherTextEncoding: CipherTextEncoding;\r\n}): number {\r\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\r\n\r\n  // Calculate the AES output length given the input length.\r\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\r\n\r\n  // Get the encoded string length of the cipherText.\r\n  let encodedCipherTextLength: number;\r\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\r\n    encodedCipherTextLength = cipherTextLength * 2;\r\n  } else if (opts.cipherTextEncoding === 'base64') {\r\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\r\n  } else {\r\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\r\n  }\r\n\r\n  if (!opts.sign) {\r\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\r\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\r\n  } else {\r\n    // Get the signed version of the JSON envelope\r\n    const { signedPayloadShell, signedPayloadValuesLength } =\r\n      getSignedCipherObjectWrapper(payloadShell);\r\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\r\n    return (\r\n      signedPayloadShell.length +\r\n      signedPayloadValuesLength +\r\n      payloadValuesLength +\r\n      encodedCipherTextLength\r\n    );\r\n  }\r\n}\r\n\r\n// todo: simplify and remove wasstring\r\n/**\r\n * Encrypt content to elliptic curve publicKey using ECIES\r\n * @param publicKey - secp256k1 public key hex string\r\n * @param content - content to encrypt\r\n * @return Object containing:\r\n *  iv (initialization vector, hex encoding),\r\n *  cipherText (cipher text either hex or base64 encoded),\r\n *  mac (message authentication code, hex encoded),\r\n *  ephemeral public key (hex encoded),\r\n *  wasString (boolean indicating with or not to return a Uint8Array or string on decrypt)\r\n * @ignore\r\n */\r\nexport async function encryptECIES(\r\n  publicKey: string,\r\n  content: Uint8Array,\r\n  wasString: boolean,\r\n  cipherTextEncoding?: CipherTextEncoding\r\n): Promise<CipherObject> {\r\n  const validity = isValidPublicKey(publicKey);\r\n  if (!validity.result) {\r\n    throw validity;\r\n  }\r\n  const ephemeralPrivateKey = utils.randomPrivateKey();\r\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\r\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\r\n  // Trim the compressed mode prefix byte\r\n  sharedSecret = sharedSecret.slice(1);\r\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\r\n  const initializationVector = utils.randomBytes(16);\r\n\r\n  const cipherText = await aes256CbcEncrypt(\r\n    initializationVector,\r\n    sharedKeys.encryptionKey,\r\n    content\r\n  );\r\n\r\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\r\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\r\n\r\n  let cipherTextString: string;\r\n\r\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\r\n    cipherTextString = bytesToHex(cipherText);\r\n  } else if (cipherTextEncoding === 'base64') {\r\n    cipherTextString = fromByteArray(cipherText);\r\n  } else {\r\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\r\n  }\r\n\r\n  const result: CipherObject = {\r\n    iv: bytesToHex(initializationVector),\r\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\r\n    cipherText: cipherTextString,\r\n    mac: bytesToHex(mac),\r\n    wasString,\r\n  };\r\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\r\n    result.cipherTextEncoding = cipherTextEncoding;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Decrypt content encrypted using ECIES\r\n * @param {String} privateKey - secp256k1 private key hex string\r\n * @param {Object} cipherObject - object to decrypt, should contain:\r\n *  iv (initialization vector), cipherText (cipher text),\r\n *  mac (message authentication code), ephemeralPublicKey\r\n *  wasString (boolean indicating with or not to return bytes or string on decrypt)\r\n * @return {Uint8Array} plaintext\r\n * @throws {FailedDecryptionError} if unable to decrypt\r\n * @ignore\r\n */\r\nexport async function decryptECIES(\r\n  privateKey: string,\r\n  cipherObject: CipherObject\r\n): Promise<Uint8Array | string> {\r\n  if (!cipherObject.ephemeralPK) {\r\n    throw new FailedDecryptionError(\r\n      'Unable to get public key from cipher object. ' +\r\n        'You might be trying to decrypt an unencrypted object.'\r\n    );\r\n  }\r\n  const ephemeralPK = cipherObject.ephemeralPK;\r\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\r\n  // Trim the compressed mode prefix byte\r\n  sharedSecret = sharedSecret.slice(1);\r\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\r\n  const ivBytes = hexToBytes(cipherObject.iv);\r\n\r\n  let cipherTextBytes: Uint8Array;\r\n\r\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\r\n    cipherTextBytes = hexToBytes(cipherObject.cipherText);\r\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\r\n    cipherTextBytes = toByteArray(cipherObject.cipherText);\r\n  } else {\r\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\r\n  }\r\n\r\n  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\r\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\r\n  const expectedMac = hexToBytes(cipherObject.mac);\r\n\r\n  if (!equalsConstTime(expectedMac, actualMac)) {\r\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\r\n  }\r\n  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\r\n\r\n  if (cipherObject.wasString) {\r\n    return bytesToUtf8(plainText);\r\n  }\r\n  return plainText;\r\n}\r\n\r\n/**\r\n * Sign content using ECDSA\r\n *\r\n * @param {string} privateKey - secp256k1 private key hex string\r\n * @param {string | Uint8Array} content - content to sign\r\n * @return {Object} contains:\r\n * signature - Hex encoded DER signature\r\n * public key - Hex encoded private string taken from privateKey\r\n * @ignore\r\n */\r\nexport function signECDSA(\r\n  privateKey: string,\r\n  content: string | Uint8Array\r\n): {\r\n  publicKey: string;\r\n  signature: string;\r\n} {\r\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\r\n  const publicKey = getPublicKeyFromPrivate(privateKey);\r\n  const contentHash = hashSha256Sync(contentBytes);\r\n  const signature = signSync(contentHash, privateKey);\r\n\r\n  return {\r\n    signature: bytesToHex(signature),\r\n    publicKey,\r\n  };\r\n}\r\n\r\n/**\r\n * Verify content using ECDSA\r\n * @param {String | Uint8Array} content - Content to verify was signed\r\n * @param {String} publicKey - secp256k1 private key hex string\r\n * @param {String} signature - Hex encoded DER signature\r\n * @return {Boolean} returns true when signature matches publickey + content, false if not\r\n * @ignore\r\n */\r\nexport function verifyECDSA(\r\n  content: string | Uint8Array,\r\n  publicKey: string,\r\n  signature: string\r\n): boolean {\r\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\r\n  const contentHash = hashSha256Sync(contentBytes);\r\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\r\n  // Set verify options to strict: false, to support the legacy stacks implementations\r\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\r\n  return verify(signature, contentHash, publicKey, { strict: false });\r\n}\r\n\r\ninterface VerifyMessageSignatureArgs {\r\n  signature: string;\r\n  message: string | Uint8Array;\r\n  publicKey: string;\r\n}\r\n\r\n/**\r\n * Verify message signature (VRS format) with recoverable public key\r\n * @deprecated The Clarity compatible {@link verifyMessageSignatureRsv} is preferred\r\n */\r\nexport function verifyMessageSignature({\r\n  signature,\r\n  message,\r\n  publicKey,\r\n}: VerifyMessageSignatureArgs): boolean {\r\n  // todo: remove method and pull body to `verifyMessageSignatureRsv`\r\n  const { r, s } = parseRecoverableSignatureVrs(signature);\r\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\r\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\r\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\r\n  // Set verify options to strict: false, to support the legacy stacks implementations\r\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\r\n  const verificationResult = verify(sig, hashedMsg, publicKey, { strict: false });\r\n\r\n  // Additional Check for Legacy Prefix ++++++++++++++++++++++++++++++++++++++++\r\n  if (verificationResult || typeof message !== 'string') return verificationResult;\r\n\r\n  const LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\r\n  const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\r\n  return verify(sig, legacyHash, publicKey, { strict: false });\r\n  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n}\r\n\r\n/**\r\n * Verifies a Clarity compatible signed message using a public key. The\r\n * `signature` option needs to be in RSV format.\r\n */\r\nexport function verifyMessageSignatureRsv({\r\n  signature,\r\n  message,\r\n  publicKey,\r\n}: VerifyMessageSignatureArgs): boolean {\r\n  return verifyMessageSignature({\r\n    signature: signatureRsvToVrs(signature),\r\n    message,\r\n    publicKey,\r\n  });\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}