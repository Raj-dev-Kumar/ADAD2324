{"ast":null,"code":"import { utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  let privateKey;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  const wasString = typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const cipherObject = await encryptECIES(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey, cipherPayload);\n    const signedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\nexport function decryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["utf8ToBytes","decryptECIES","encryptECIES","signECDSA","getPublicKeyFromPrivate","encryptContent","content","options","opts","Object","assign","privateKey","publicKey","Error","wasString","contentBytes","cipherObject","cipherTextEncoding","cipherPayload","JSON","stringify","sign","signatureObject","signedCipherObject","signature","cipherText","decryptContent","parse","err","SyntaxError"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\encryption\\src\\encryption.ts"],"sourcesContent":["import { utf8ToBytes } from '@stacks/common';\r\nimport {\r\n  CipherTextEncoding,\r\n  decryptECIES,\r\n  encryptECIES,\r\n  signECDSA,\r\n  SignedCipherObject,\r\n} from './ec';\r\nimport { getPublicKeyFromPrivate } from './keys';\r\n\r\nexport interface EncryptionOptions {\r\n  /**\r\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\r\n   * app private key. If a string is specified, it is used as the private key instead\r\n   * of the user's app private key.\r\n   * @default false\r\n   */\r\n  sign?: boolean | string;\r\n  /**\r\n   * String encoding format for the cipherText bytes.\r\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\r\n   * Only used if the `encrypt` option is also used.\r\n   * Note: in the future this should default to 'base64' for the significant\r\n   * file size reduction.\r\n   */\r\n  cipherTextEncoding?: CipherTextEncoding;\r\n  /**\r\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\r\n   * For example stringified JSON.\r\n   * If true, then when the ciphertext is decrypted, it will be returned as\r\n   * a `string` type variable, otherwise will be returned as bytes.\r\n   */\r\n  wasString?: boolean;\r\n}\r\n\r\n/**\r\n * Specify encryption options, and whether to sign the ciphertext.\r\n */\r\nexport interface EncryptContentOptions extends EncryptionOptions {\r\n  /**\r\n   * Encrypt the data with this key.\r\n   */\r\n  publicKey?: string;\r\n  /**\r\n   * Encrypt the data with the public key corresponding to the supplied private key\r\n   */\r\n  privateKey?: string;\r\n}\r\n\r\n/**\r\n * Encrypts the data provided with the app public key.\r\n * @param {string | Uint8Array} content - data to encrypt\r\n * @param {Object} [options=null] - options object\r\n * @param {String} options.publicKey - the hex string of the ECDSA public\r\n * key to use for encryption. If not provided, will use user's appPublicKey.\r\n * @return {String} Stringified ciphertext object\r\n */\r\nexport async function encryptContent(\r\n  content: string | Uint8Array,\r\n  options?: EncryptContentOptions\r\n): Promise<string> {\r\n  const opts = Object.assign({}, options);\r\n  let privateKey: string | undefined;\r\n  if (!opts.publicKey) {\r\n    if (!opts.privateKey) {\r\n      throw new Error('Either public key or private key must be supplied for encryption.');\r\n    }\r\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\r\n  }\r\n  const wasString =\r\n    typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\r\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\r\n  const cipherObject = await encryptECIES(\r\n    opts.publicKey,\r\n    contentBytes,\r\n    wasString,\r\n    opts.cipherTextEncoding\r\n  );\r\n  let cipherPayload = JSON.stringify(cipherObject);\r\n  if (opts.sign) {\r\n    if (typeof opts.sign === 'string') {\r\n      privateKey = opts.sign;\r\n    } else if (!privateKey) {\r\n      privateKey = opts.privateKey;\r\n    }\r\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\r\n    const signedCipherObject: SignedCipherObject = {\r\n      signature: signatureObject.signature,\r\n      publicKey: signatureObject.publicKey,\r\n      cipherText: cipherPayload,\r\n    };\r\n    cipherPayload = JSON.stringify(signedCipherObject);\r\n  }\r\n  return cipherPayload;\r\n}\r\n\r\n/**\r\n * Decrypts data encrypted with `encryptContent` with the\r\n * transit private key.\r\n * @param {string | Uint8Array} content - encrypted content.\r\n * @param {Object} [options=null] - options object\r\n * @param {string} options.privateKey - the hex string of the ECDSA private\r\n * key to use for decryption. If not provided, will use user's appPrivateKey.\r\n * @return {string | Uint8Array} decrypted content.\r\n */\r\nexport function decryptContent(\r\n  content: string,\r\n  options?: {\r\n    privateKey?: string;\r\n  }\r\n): Promise<string | Uint8Array> {\r\n  const opts = Object.assign({}, options);\r\n  if (!opts.privateKey) {\r\n    throw new Error('Private key is required for decryption.');\r\n  }\r\n\r\n  try {\r\n    const cipherObject = JSON.parse(content);\r\n    return decryptECIES(opts.privateKey, cipherObject);\r\n  } catch (err) {\r\n    if (err instanceof SyntaxError) {\r\n      throw new Error(\r\n        'Failed to parse encrypted content JSON. The content may not ' +\r\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\r\n      );\r\n    } else {\r\n      throw err;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,gBAAgB;AAC5C,SAEEC,YAAY,EACZC,YAAY,EACZC,SAAS,QAEJ,MAAM;AACb,SAASC,uBAAuB,QAAQ,QAAQ;AAiDhD,OAAO,eAAeC,cAAcA,CAClCC,OAA4B,EAC5BC,OAA+B;EAE/B,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,CAAC;EACvC,IAAII,UAA8B;EAClC,IAAI,CAACH,IAAI,CAACI,SAAS,EAAE;IACnB,IAAI,CAACJ,IAAI,CAACG,UAAU,EAAE;MACpB,MAAM,IAAIE,KAAK,CAAC,mEAAmE,CAAC;;IAEtFL,IAAI,CAACI,SAAS,GAAGR,uBAAuB,CAACI,IAAI,CAACG,UAAU,CAAC;;EAE3D,MAAMG,SAAS,GACb,OAAON,IAAI,CAACM,SAAS,KAAK,SAAS,GAAGN,IAAI,CAACM,SAAS,GAAG,OAAOR,OAAO,KAAK,QAAQ;EACpF,MAAMS,YAAY,GAAG,OAAOT,OAAO,KAAK,QAAQ,GAAGN,WAAW,CAACM,OAAO,CAAC,GAAGA,OAAO;EACjF,MAAMU,YAAY,GAAG,MAAMd,YAAY,CACrCM,IAAI,CAACI,SAAS,EACdG,YAAY,EACZD,SAAS,EACTN,IAAI,CAACS,kBAAkB,CACxB;EACD,IAAIC,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACJ,YAAY,CAAC;EAChD,IAAIR,IAAI,CAACa,IAAI,EAAE;IACb,IAAI,OAAOb,IAAI,CAACa,IAAI,KAAK,QAAQ,EAAE;MACjCV,UAAU,GAAGH,IAAI,CAACa,IAAI;KACvB,MAAM,IAAI,CAACV,UAAU,EAAE;MACtBA,UAAU,GAAGH,IAAI,CAACG,UAAU;;IAE9B,MAAMW,eAAe,GAAGnB,SAAS,CAACQ,UAAW,EAAEO,aAAa,CAAC;IAC7D,MAAMK,kBAAkB,GAAuB;MAC7CC,SAAS,EAAEF,eAAe,CAACE,SAAS;MACpCZ,SAAS,EAAEU,eAAe,CAACV,SAAS;MACpCa,UAAU,EAAEP;KACb;IACDA,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACG,kBAAkB,CAAC;;EAEpD,OAAOL,aAAa;AACtB;AAWA,OAAM,SAAUQ,cAAcA,CAC5BpB,OAAe,EACfC,OAEC;EAED,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,CAAC;EACvC,IAAI,CAACC,IAAI,CAACG,UAAU,EAAE;IACpB,MAAM,IAAIE,KAAK,CAAC,yCAAyC,CAAC;;EAG5D,IAAI;IACF,MAAMG,YAAY,GAAGG,IAAI,CAACQ,KAAK,CAACrB,OAAO,CAAC;IACxC,OAAOL,YAAY,CAACO,IAAI,CAACG,UAAU,EAAEK,YAAY,CAAC;GACnD,CAAC,OAAOY,GAAG,EAAE;IACZ,IAAIA,GAAG,YAAYC,WAAW,EAAE;MAC9B,MAAM,IAAIhB,KAAK,CACb,8DAA8D,GAC5D,iEAAiE,CACpE;KACF,MAAM;MACL,MAAMe,GAAG;;;AAGf"},"metadata":{},"sourceType":"module","externalDependencies":[]}