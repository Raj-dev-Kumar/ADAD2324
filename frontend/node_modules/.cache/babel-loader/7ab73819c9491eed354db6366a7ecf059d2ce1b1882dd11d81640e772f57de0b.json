{"ast":null,"code":"import { readUInt16LE, readUInt32LE, readUInt8, writeUInt16LE, writeUInt32LE, writeUInt8 } from '@stacks/common';\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction ensureUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');\n}\nexport function encode(number, bytes, offset = 0) {\n  ensureUInt53(number);\n  if (!bytes) bytes = new Uint8Array(encodingLength(number));\n  if (number < 0xfd) {\n    writeUInt8(bytes, number, offset);\n  } else if (number <= 65535) {\n    writeUInt8(bytes, 0xfd, offset);\n    writeUInt16LE(bytes, number, offset + 1);\n  } else if (number <= 4294967295) {\n    writeUInt8(bytes, 0xfe, offset);\n    writeUInt32LE(bytes, number, offset + 1);\n  } else {\n    writeUInt8(bytes, 0xff, offset);\n    writeUInt32LE(bytes, number >>> 0, offset + 1);\n    writeUInt32LE(bytes, number / 4294967296 | 0, offset + 5);\n  }\n  return bytes;\n}\nexport function decode(bytes, offset = 0) {\n  const first = readUInt8(bytes, offset);\n  if (first < 0xfd) {\n    return first;\n  } else if (first === 0xfd) {\n    return readUInt16LE(bytes, offset + 1);\n  } else if (first === 0xfe) {\n    return readUInt32LE(bytes, offset + 1);\n  } else {\n    const lo = readUInt32LE(bytes, offset + 1);\n    const hi = readUInt32LE(bytes, offset + 5);\n    const number = hi * 4294967296 + lo;\n    ensureUInt53(number);\n    return number;\n  }\n}\nexport function encodingLength(number) {\n  ensureUInt53(number);\n  return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;\n}","map":{"version":3,"names":["readUInt16LE","readUInt32LE","readUInt8","writeUInt16LE","writeUInt32LE","writeUInt8","MAX_SAFE_INTEGER","ensureUInt53","n","RangeError","encode","number","bytes","offset","Uint8Array","encodingLength","decode","first","lo","hi"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\encryption\\src\\varuint.ts"],"sourcesContent":["import {\r\n  readUInt16LE,\r\n  readUInt32LE,\r\n  readUInt8,\r\n  writeUInt16LE,\r\n  writeUInt32LE,\r\n  writeUInt8,\r\n} from '@stacks/common';\r\n\r\n// The following methods are based on `bitcoinjs/varuint-bitcoin` implementation\r\n// https://github.com/bitcoinjs/varuint-bitcoin/blob/8342fe7362f20a412d61b9ade20839aafaa7f78e/index.js\r\n\r\n// Copyright (c) 2016 Kirill Fomichev\r\n// Parts of this software are based on https://github.com/mappum/bitcoin-protocol\r\n// Copyright (c) 2016 Matt Bell\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the “Software”), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// Number.MAX_SAFE_INTEGER\r\nconst MAX_SAFE_INTEGER = 9_007_199_254_740_991;\r\n\r\nfunction ensureUInt53(n: number) {\r\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');\r\n}\r\n\r\nexport function encode(number: number, bytes?: Uint8Array, offset: number = 0) {\r\n  ensureUInt53(number);\r\n  if (!bytes) bytes = new Uint8Array(encodingLength(number));\r\n\r\n  // 8 bit\r\n  if (number < 0xfd) {\r\n    writeUInt8(bytes, number, offset);\r\n\r\n    // 16 bit\r\n  } else if (number <= 0xff_ff) {\r\n    writeUInt8(bytes, 0xfd, offset);\r\n    writeUInt16LE(bytes, number, offset + 1);\r\n\r\n    // 32 bit\r\n  } else if (number <= 0xff_ff_ff_ff) {\r\n    writeUInt8(bytes, 0xfe, offset);\r\n    writeUInt32LE(bytes, number, offset + 1);\r\n\r\n    // 64 bit\r\n  } else {\r\n    writeUInt8(bytes, 0xff, offset);\r\n    writeUInt32LE(bytes, number >>> 0, offset + 1);\r\n    writeUInt32LE(bytes, (number / 0x1_00_00_00_00) | 0, offset + 5);\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\nexport function decode(bytes: Uint8Array, offset: number = 0) {\r\n  const first = readUInt8(bytes, offset);\r\n\r\n  // 8 bit\r\n  if (first < 0xfd) {\r\n    return first;\r\n\r\n    // 16 bit\r\n  } else if (first === 0xfd) {\r\n    return readUInt16LE(bytes, offset + 1);\r\n\r\n    // 32 bit\r\n  } else if (first === 0xfe) {\r\n    return readUInt32LE(bytes, offset + 1);\r\n\r\n    // 64 bit\r\n  } else {\r\n    const lo = readUInt32LE(bytes, offset + 1);\r\n    const hi = readUInt32LE(bytes, offset + 5);\r\n    const number = hi * 0x01_00_00_00_00 + lo;\r\n    ensureUInt53(number);\r\n\r\n    return number;\r\n  }\r\n}\r\n\r\nexport function encodingLength(number: number) {\r\n  ensureUInt53(number);\r\n\r\n  return number < 0xfd ? 1 : number <= 0xff_ff ? 3 : number <= 0xff_ff_ff_ff ? 5 : 9;\r\n}\r\n"],"mappings":"AAAA,SACEA,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,aAAa,EACbC,aAAa,EACbC,UAAU,QACL,gBAAgB;AAkBvB,MAAMC,gBAAgB,GAAG,gBAAqB;AAE9C,SAASC,YAAYA,CAACC,CAAS;EAC7B,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAGF,gBAAgB,IAAIE,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM,IAAIC,UAAU,CAAC,oBAAoB,CAAC;AAC9F;AAEA,OAAM,SAAUC,MAAMA,CAACC,MAAc,EAAEC,KAAkB,EAAEC,MAAA,GAAiB,CAAC;EAC3EN,YAAY,CAACI,MAAM,CAAC;EACpB,IAAI,CAACC,KAAK,EAAEA,KAAK,GAAG,IAAIE,UAAU,CAACC,cAAc,CAACJ,MAAM,CAAC,CAAC;EAG1D,IAAIA,MAAM,GAAG,IAAI,EAAE;IACjBN,UAAU,CAACO,KAAK,EAAED,MAAM,EAAEE,MAAM,CAAC;GAGlC,MAAM,IAAIF,MAAM,IAAI,KAAO,EAAE;IAC5BN,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BV,aAAa,CAACS,KAAK,EAAED,MAAM,EAAEE,MAAM,GAAG,CAAC,CAAC;GAGzC,MAAM,IAAIF,MAAM,IAAI,UAAa,EAAE;IAClCN,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BT,aAAa,CAACQ,KAAK,EAAED,MAAM,EAAEE,MAAM,GAAG,CAAC,CAAC;GAGzC,MAAM;IACLR,UAAU,CAACO,KAAK,EAAE,IAAI,EAAEC,MAAM,CAAC;IAC/BT,aAAa,CAACQ,KAAK,EAAED,MAAM,KAAK,CAAC,EAAEE,MAAM,GAAG,CAAC,CAAC;IAC9CT,aAAa,CAACQ,KAAK,EAAGD,MAAM,GAAG,UAAe,GAAI,CAAC,EAAEE,MAAM,GAAG,CAAC,CAAC;;EAGlE,OAAOD,KAAK;AACd;AAEA,OAAM,SAAUI,MAAMA,CAACJ,KAAiB,EAAEC,MAAA,GAAiB,CAAC;EAC1D,MAAMI,KAAK,GAAGf,SAAS,CAACU,KAAK,EAAEC,MAAM,CAAC;EAGtC,IAAII,KAAK,GAAG,IAAI,EAAE;IAChB,OAAOA,KAAK;GAGb,MAAM,IAAIA,KAAK,KAAK,IAAI,EAAE;IACzB,OAAOjB,YAAY,CAACY,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;GAGvC,MAAM,IAAII,KAAK,KAAK,IAAI,EAAE;IACzB,OAAOhB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;GAGvC,MAAM;IACL,MAAMK,EAAE,GAAGjB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMM,EAAE,GAAGlB,YAAY,CAACW,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMF,MAAM,GAAGQ,EAAE,GAAG,UAAgB,GAAGD,EAAE;IACzCX,YAAY,CAACI,MAAM,CAAC;IAEpB,OAAOA,MAAM;;AAEjB;AAEA,OAAM,SAAUI,cAAcA,CAACJ,MAAc;EAC3CJ,YAAY,CAACI,MAAM,CAAC;EAEpB,OAAOA,MAAM,GAAG,IAAI,GAAG,CAAC,GAAGA,MAAM,IAAI,KAAO,GAAG,CAAC,GAAGA,MAAM,IAAI,UAAa,GAAG,CAAC,GAAG,CAAC;AACpF"},"metadata":{},"sourceType":"module","externalDependencies":[]}