{"ast":null,"code":"import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength\n  };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName)\n  };\n}\nexport function createAddress(c32AddressString) {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1]\n  };\n}\nexport function parsePrincipalString(principalString) {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\nexport function createContractPrincipal(addressString, contractName) {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name\n  };\n}\nexport function createStandardPrincipal(addressString) {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr\n  };\n}","map":{"version":3,"names":["MAX_STRING_LENGTH_BYTES","PostConditionPrincipalID","StacksMessageType","c32addressDecode","exceedsMaxLengthBytes","parseAssetInfoString","id","assetAddress","assetContractName","assetTokenName","split","assetInfo","createAssetInfo","createLPString","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","Error","type","LengthPrefixedString","addressString","contractName","assetName","AssetInfo","address","createAddress","c32AddressString","addressData","Address","version","hash160","parsePrincipalString","principalString","includes","createContractPrincipal","createStandardPrincipal","addr","name","Principal","prefix","Contract","Standard"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\postcondition-types.ts"],"sourcesContent":["import {\r\n  FungibleConditionCode,\r\n  MAX_STRING_LENGTH_BYTES,\r\n  NonFungibleConditionCode,\r\n  PostConditionPrincipalID,\r\n  PostConditionType,\r\n  StacksMessageType,\r\n} from './constants';\r\nimport { c32addressDecode } from 'c32check';\r\nimport { Address } from './common';\r\nimport { ClarityValue } from './clarity';\r\nimport { exceedsMaxLengthBytes } from './utils';\r\n\r\nexport interface StandardPrincipal {\r\n  readonly type: StacksMessageType.Principal;\r\n  readonly prefix: PostConditionPrincipalID.Standard;\r\n  readonly address: Address;\r\n}\r\n\r\nexport interface ContractPrincipal {\r\n  readonly type: StacksMessageType.Principal;\r\n  readonly prefix: PostConditionPrincipalID.Contract;\r\n  readonly address: Address;\r\n  readonly contractName: LengthPrefixedString;\r\n}\r\n\r\nexport interface LengthPrefixedString {\r\n  readonly type: StacksMessageType.LengthPrefixedString;\r\n  readonly content: string;\r\n  readonly lengthPrefixBytes: number;\r\n  readonly maxLengthBytes: number;\r\n}\r\n\r\nexport interface AssetInfo {\r\n  readonly type: StacksMessageType.AssetInfo;\r\n  readonly address: Address;\r\n  readonly contractName: LengthPrefixedString;\r\n  readonly assetName: LengthPrefixedString;\r\n}\r\n\r\nexport interface STXPostCondition {\r\n  readonly type: StacksMessageType.PostCondition;\r\n  readonly conditionType: PostConditionType.STX;\r\n  readonly principal: PostConditionPrincipal;\r\n  readonly conditionCode: FungibleConditionCode;\r\n  readonly amount: bigint;\r\n}\r\n\r\nexport interface FungiblePostCondition {\r\n  readonly type: StacksMessageType.PostCondition;\r\n  readonly conditionType: PostConditionType.Fungible;\r\n  readonly principal: PostConditionPrincipal;\r\n  readonly conditionCode: FungibleConditionCode;\r\n  readonly amount: bigint;\r\n  readonly assetInfo: AssetInfo;\r\n}\r\n\r\nexport interface NonFungiblePostCondition {\r\n  readonly type: StacksMessageType.PostCondition;\r\n  readonly conditionType: PostConditionType.NonFungible;\r\n  readonly principal: PostConditionPrincipal;\r\n  readonly conditionCode: NonFungibleConditionCode;\r\n  /** Structure that identifies the token type. */\r\n  readonly assetInfo: AssetInfo;\r\n  /** The Clarity value that names the token instance. */\r\n  readonly assetName: ClarityValue;\r\n}\r\n\r\nexport function parseAssetInfoString(id: string): AssetInfo {\r\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\r\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\r\n  return assetInfo;\r\n}\r\n\r\nexport function createLPString(content: string): LengthPrefixedString;\r\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\r\nexport function createLPString(\r\n  content: string,\r\n  lengthPrefixBytes: number,\r\n  maxLengthBytes: number\r\n): LengthPrefixedString;\r\nexport function createLPString(\r\n  content: string,\r\n  lengthPrefixBytes?: number,\r\n  maxLengthBytes?: number\r\n): LengthPrefixedString {\r\n  const prefixLength = lengthPrefixBytes || 1;\r\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\r\n  if (exceedsMaxLengthBytes(content, maxLength)) {\r\n    throw new Error(`String length exceeds maximum bytes ${maxLength}`);\r\n  }\r\n  return {\r\n    type: StacksMessageType.LengthPrefixedString,\r\n    content,\r\n    lengthPrefixBytes: prefixLength,\r\n    maxLengthBytes: maxLength,\r\n  };\r\n}\r\n\r\nexport function createAssetInfo(\r\n  addressString: string,\r\n  contractName: string,\r\n  assetName: string\r\n): AssetInfo {\r\n  return {\r\n    type: StacksMessageType.AssetInfo,\r\n    address: createAddress(addressString),\r\n    contractName: createLPString(contractName),\r\n    assetName: createLPString(assetName),\r\n  };\r\n}\r\n\r\nexport function createAddress(c32AddressString: string): Address {\r\n  const addressData = c32addressDecode(c32AddressString);\r\n  return {\r\n    type: StacksMessageType.Address,\r\n    version: addressData[0],\r\n    hash160: addressData[1],\r\n  };\r\n}\r\n\r\n/**\r\n * Parses a principal string for either a standard principal or contract principal.\r\n * @param principalString - String in the format `{address}.{contractName}`\r\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\r\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\r\n */\r\nexport function parsePrincipalString(\r\n  principalString: string\r\n): StandardPrincipal | ContractPrincipal {\r\n  if (principalString.includes('.')) {\r\n    const [address, contractName] = principalString.split('.');\r\n    return createContractPrincipal(address, contractName);\r\n  } else {\r\n    return createStandardPrincipal(principalString);\r\n  }\r\n}\r\n\r\nexport function createContractPrincipal(\r\n  addressString: string,\r\n  contractName: string\r\n): ContractPrincipal {\r\n  const addr = createAddress(addressString);\r\n  const name = createLPString(contractName);\r\n  return {\r\n    type: StacksMessageType.Principal,\r\n    prefix: PostConditionPrincipalID.Contract,\r\n    address: addr,\r\n    contractName: name,\r\n  };\r\n}\r\n\r\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\r\n  const addr = createAddress(addressString);\r\n  return {\r\n    type: StacksMessageType.Principal,\r\n    prefix: PostConditionPrincipalID.Standard,\r\n    address: addr,\r\n  };\r\n}\r\n\r\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\r\n\r\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\r\n"],"mappings":"AAAA,SAEEA,uBAAuB,EAEvBC,wBAAwB,EAExBC,iBAAiB,QACZ,aAAa;AACpB,SAASC,gBAAgB,QAAQ,UAAU;AAG3C,SAASC,qBAAqB,QAAQ,SAAS;AAyD/C,OAAM,SAAUC,oBAAoBA,CAACC,EAAU;EAC7C,MAAM,CAACC,YAAY,EAAEC,iBAAiB,EAAEC,cAAc,CAAC,GAAGH,EAAE,CAACI,KAAK,CAAC,OAAO,CAAC;EAC3E,MAAMC,SAAS,GAAGC,eAAe,CAACL,YAAY,EAAEC,iBAAiB,EAAEC,cAAc,CAAC;EAClF,OAAOE,SAAS;AAClB;AASA,OAAM,SAAUE,cAAcA,CAC5BC,OAAe,EACfC,iBAA0B,EAC1BC,cAAuB;EAEvB,MAAMC,YAAY,GAAGF,iBAAiB,IAAI,CAAC;EAC3C,MAAMG,SAAS,GAAGF,cAAc,IAAIhB,uBAAuB;EAC3D,IAAII,qBAAqB,CAACU,OAAO,EAAEI,SAAS,CAAC,EAAE;IAC7C,MAAM,IAAIC,KAAK,CAAC,uCAAuCD,SAAS,EAAE,CAAC;;EAErE,OAAO;IACLE,IAAI,EAAElB,iBAAiB,CAACmB,oBAAoB;IAC5CP,OAAO;IACPC,iBAAiB,EAAEE,YAAY;IAC/BD,cAAc,EAAEE;GACjB;AACH;AAEA,OAAM,SAAUN,eAAeA,CAC7BU,aAAqB,EACrBC,YAAoB,EACpBC,SAAiB;EAEjB,OAAO;IACLJ,IAAI,EAAElB,iBAAiB,CAACuB,SAAS;IACjCC,OAAO,EAAEC,aAAa,CAACL,aAAa,CAAC;IACrCC,YAAY,EAAEV,cAAc,CAACU,YAAY,CAAC;IAC1CC,SAAS,EAAEX,cAAc,CAACW,SAAS;GACpC;AACH;AAEA,OAAM,SAAUG,aAAaA,CAACC,gBAAwB;EACpD,MAAMC,WAAW,GAAG1B,gBAAgB,CAACyB,gBAAgB,CAAC;EACtD,OAAO;IACLR,IAAI,EAAElB,iBAAiB,CAAC4B,OAAO;IAC/BC,OAAO,EAAEF,WAAW,CAAC,CAAC,CAAC;IACvBG,OAAO,EAAEH,WAAW,CAAC,CAAC;GACvB;AACH;AAQA,OAAM,SAAUI,oBAAoBA,CAClCC,eAAuB;EAEvB,IAAIA,eAAe,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;IACjC,MAAM,CAACT,OAAO,EAAEH,YAAY,CAAC,GAAGW,eAAe,CAACxB,KAAK,CAAC,GAAG,CAAC;IAC1D,OAAO0B,uBAAuB,CAACV,OAAO,EAAEH,YAAY,CAAC;GACtD,MAAM;IACL,OAAOc,uBAAuB,CAACH,eAAe,CAAC;;AAEnD;AAEA,OAAM,SAAUE,uBAAuBA,CACrCd,aAAqB,EACrBC,YAAoB;EAEpB,MAAMe,IAAI,GAAGX,aAAa,CAACL,aAAa,CAAC;EACzC,MAAMiB,IAAI,GAAG1B,cAAc,CAACU,YAAY,CAAC;EACzC,OAAO;IACLH,IAAI,EAAElB,iBAAiB,CAACsC,SAAS;IACjCC,MAAM,EAAExC,wBAAwB,CAACyC,QAAQ;IACzChB,OAAO,EAAEY,IAAI;IACbf,YAAY,EAAEgB;GACf;AACH;AAEA,OAAM,SAAUF,uBAAuBA,CAACf,aAAqB;EAC3D,MAAMgB,IAAI,GAAGX,aAAa,CAACL,aAAa,CAAC;EACzC,OAAO;IACLF,IAAI,EAAElB,iBAAiB,CAACsC,SAAS;IACjCC,MAAM,EAAExC,wBAAwB,CAAC0C,QAAQ;IACzCjB,OAAO,EAAEY;GACV;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}