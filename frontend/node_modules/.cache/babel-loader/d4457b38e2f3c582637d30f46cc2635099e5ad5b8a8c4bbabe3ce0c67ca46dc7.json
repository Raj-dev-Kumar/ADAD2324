{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, Point, Signature, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, hexToBigInt, hexToBytes, intToHex, parseRecoverableSignatureVrs, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, signatureRsvToVrs, signatureVrsToRsv } from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { addressFromVersionHash, addressHashModeToVersion, addressToString, createMessageSignature } from './common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, PubKeyEncoding, StacksMessageType, TransactionVersion, UNCOMPRESSED_PUBKEY_LENGTH_BYTES } from './constants';\nimport { hash160, hashP2PKH } from './utils';\nutils.hmacSha256Sync = (key, ...msgs) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion.Mainnet) {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion.Mainnet) {\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  const addrString = addressToString(addr);\n  return addrString;\n}\nexport function createStacksPublicKey(key) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key)\n  };\n}\nexport function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\nexport function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {\n  return publicKeyFromSignatureVrs(messageHash, {\n    ...messageSignature,\n    data: signatureRsvToVrs(messageSignature.data)\n  }, pubKeyEncoding);\n}\nexport function publicKeyFromBytes(data) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data\n  };\n}\nexport function isCompressed(key) {\n  return !bytesToHex(key.data).startsWith('04');\n}\nexport function publicKeyToString(key) {\n  return bytesToHex(key.data);\n}\nexport function serializePublicKey(key) {\n  return key.data.slice();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\nexport function compressPublicKey(publicKey) {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\nexport function deserializePublicKey(bytesReader) {\n  const fieldId = bytesReader.readUInt8();\n  const keyLength = fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n  const data = privateKeyToBytes(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return {\n    data,\n    compressed\n  };\n}\nexport function makeRandomPrivKey() {\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\nexport function signWithKey(privateKey, messageHash) {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();\n  return createMessageSignature(recoverableSignatureString);\n}\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey\n}) {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return {\n    ...messageSignature,\n    data: signatureVrsToRsv(messageSignature.data)\n  };\n}\nexport function getPublicKey(privateKey) {\n  return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n  return bytesToHex(privateKey.data);\n}\nexport function publicKeyToAddress(version, publicKey) {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","nobleGetPublicKey","Point","Signature","signSync","utils","bytesToHex","concatArray","hexToBigInt","hexToBytes","intToHex","parseRecoverableSignatureVrs","privateKeyToBytes","PRIVATE_KEY_COMPRESSED_LENGTH","signatureRsvToVrs","signatureVrsToRsv","c32address","addressFromVersionHash","addressHashModeToVersion","addressToString","createMessageSignature","AddressHashMode","COMPRESSED_PUBKEY_LENGTH_BYTES","PubKeyEncoding","StacksMessageType","TransactionVersion","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","hash160","hashP2PKH","hmacSha256Sync","key","msgs","h","create","forEach","msg","update","digest","getAddressFromPrivateKey","privateKey","transactionVersion","Mainnet","pubKey","pubKeyfromPrivKey","getAddressFromPublicKey","data","publicKey","addrVer","SerializeP2PKH","addr","addrString","createStacksPublicKey","type","PublicKey","publicKeyFromSignatureVrs","messageHash","messageSignature","pubKeyEncoding","Compressed","parsedSignature","signature","r","s","point","fromSignature","recoveryId","compressed","toHex","publicKeyFromSignatureRsv","publicKeyFromBytes","isCompressed","startsWith","publicKeyToString","serializePublicKey","slice","privKey","createStacksPrivateKey","compressPublicKey","hex","fromHex","deserializePublicKey","bytesReader","fieldId","readUInt8","keyLength","readBytes","length","makeRandomPrivKey","randomPrivateKey","signWithKey","rawSignature","canonical","recovered","Error","recoveryIdHex","recoverableSignatureString","toCompactHex","signMessageHashRsv","privateKeyToString","publicKeyToAddress","version"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport {\r\n  getPublicKey as nobleGetPublicKey,\r\n  Point,\r\n  Signature,\r\n  signSync,\r\n  utils,\r\n} from '@noble/secp256k1';\r\nimport {\r\n  bytesToHex,\r\n  concatArray,\r\n  hexToBigInt,\r\n  hexToBytes,\r\n  intToHex,\r\n  parseRecoverableSignatureVrs,\r\n  privateKeyToBytes,\r\n  PRIVATE_KEY_COMPRESSED_LENGTH,\r\n  signatureRsvToVrs,\r\n  signatureVrsToRsv,\r\n} from '@stacks/common';\r\nimport { c32address } from 'c32check';\r\nimport { BytesReader } from './bytesReader';\r\nimport {\r\n  addressFromVersionHash,\r\n  addressHashModeToVersion,\r\n  addressToString,\r\n  createMessageSignature,\r\n  MessageSignature,\r\n} from './common';\r\nimport {\r\n  AddressHashMode,\r\n  AddressVersion,\r\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\r\n  PubKeyEncoding,\r\n  StacksMessageType,\r\n  TransactionVersion,\r\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\r\n} from './constants';\r\nimport { hash160, hashP2PKH } from './utils';\r\n\r\n/**\r\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\r\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\r\n * secp256k1.signSync is used within signWithKey in this file\r\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\r\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\r\n */\r\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\r\n  const h = hmac.create(sha256, key);\r\n  msgs.forEach(msg => h.update(msg));\r\n  return h.digest();\r\n};\r\n\r\nexport interface StacksPublicKey {\r\n  readonly type: StacksMessageType.PublicKey;\r\n  readonly data: Uint8Array;\r\n}\r\n\r\n/** Creates a P2PKH address string from the given private key and tx version. */\r\nexport function getAddressFromPrivateKey(\r\n  /** Private key bytes or hex string */\r\n  privateKey: string | Uint8Array,\r\n  transactionVersion = TransactionVersion.Mainnet\r\n): string {\r\n  const pubKey = pubKeyfromPrivKey(privateKey);\r\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\r\n}\r\n\r\n/** Creates a P2PKH address string from the given public key and tx version. */\r\nexport function getAddressFromPublicKey(\r\n  /** Public key bytes or hex string */\r\n  publicKey: string | Uint8Array,\r\n  transactionVersion = TransactionVersion.Mainnet\r\n): string {\r\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\r\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\r\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\r\n  const addrString = addressToString(addr);\r\n  return addrString;\r\n}\r\n\r\nexport function createStacksPublicKey(key: string): StacksPublicKey {\r\n  return {\r\n    type: StacksMessageType.PublicKey,\r\n    data: hexToBytes(key),\r\n  };\r\n}\r\n\r\nexport function publicKeyFromSignatureVrs(\r\n  messageHash: string,\r\n  messageSignature: MessageSignature,\r\n  pubKeyEncoding = PubKeyEncoding.Compressed\r\n): string {\r\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\r\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\r\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\r\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\r\n  return point.toHex(compressed);\r\n}\r\n\r\nexport function publicKeyFromSignatureRsv(\r\n  messageHash: string,\r\n  messageSignature: MessageSignature,\r\n  pubKeyEncoding = PubKeyEncoding.Compressed\r\n): string {\r\n  return publicKeyFromSignatureVrs(\r\n    messageHash,\r\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\r\n    pubKeyEncoding\r\n  );\r\n}\r\n\r\nexport function publicKeyFromBytes(data: Uint8Array): StacksPublicKey {\r\n  return { type: StacksMessageType.PublicKey, data };\r\n}\r\n\r\nexport function isCompressed(key: StacksPublicKey): boolean {\r\n  return !bytesToHex(key.data).startsWith('04');\r\n}\r\n\r\nexport function publicKeyToString(key: StacksPublicKey): string {\r\n  return bytesToHex(key.data);\r\n}\r\n\r\nexport function serializePublicKey(key: StacksPublicKey): Uint8Array {\r\n  return key.data.slice();\r\n}\r\n\r\nexport function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey {\r\n  const privKey = createStacksPrivateKey(privateKey);\r\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\r\n  return createStacksPublicKey(bytesToHex(publicKey));\r\n}\r\n\r\nexport function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey {\r\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\r\n  const compressed = Point.fromHex(hex).toHex(true);\r\n  return createStacksPublicKey(compressed);\r\n}\r\n\r\nexport function deserializePublicKey(bytesReader: BytesReader): StacksPublicKey {\r\n  const fieldId = bytesReader.readUInt8();\r\n  const keyLength =\r\n    fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\r\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\r\n}\r\n\r\nexport interface StacksPrivateKey {\r\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\r\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\r\n  compressed: boolean;\r\n  data: Uint8Array;\r\n}\r\n\r\nexport function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey {\r\n  const data = privateKeyToBytes(key);\r\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\r\n  return { data, compressed };\r\n}\r\n\r\nexport function makeRandomPrivKey(): StacksPrivateKey {\r\n  return createStacksPrivateKey(utils.randomPrivateKey());\r\n}\r\n\r\n/**\r\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\r\n * @returns A recoverable signature (in VRS order)\r\n */\r\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\r\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\r\n    canonical: true,\r\n    recovered: true,\r\n  });\r\n  if (recoveryId == null) {\r\n    throw new Error('No signature recoveryId received');\r\n  }\r\n  const recoveryIdHex = intToHex(recoveryId, 1);\r\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\r\n  return createMessageSignature(recoverableSignatureString);\r\n}\r\n\r\n/**\r\n * Signs a message using a private key. The resulting signature along with the\r\n * original message can be verified using {@link verifyMessageSignatureRsv}\r\n * @returns A recoverable signature (in RSV order)\r\n */\r\nexport function signMessageHashRsv({\r\n  messageHash,\r\n  privateKey,\r\n}: {\r\n  messageHash: string;\r\n  privateKey: StacksPrivateKey;\r\n}): MessageSignature {\r\n  const messageSignature = signWithKey(privateKey, messageHash);\r\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\r\n}\r\n\r\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\r\n  return pubKeyfromPrivKey(privateKey.data);\r\n}\r\n\r\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\r\n  return bytesToHex(privateKey.data);\r\n}\r\n\r\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\r\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}