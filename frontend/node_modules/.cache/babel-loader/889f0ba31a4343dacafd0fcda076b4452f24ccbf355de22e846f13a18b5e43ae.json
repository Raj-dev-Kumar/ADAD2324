{"ast":null,"code":"import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { getAddressFromPublicKey } from '@stacks/transactions';\nexport function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = nextYear()) {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  if (!subject) {\n    subject = {\n      publicKey\n    };\n  }\n  if (!issuer) {\n    issuer = {\n      publicKey\n    };\n  }\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\nexport function wrapProfileToken(token) {\n  return {\n    token,\n    decodedToken: decodeToken(token)\n  };\n}\nexport function verifyProfileToken(token, publicKeyOrAddress) {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n  const issuerPublicKey = payload.issuer.publicKey;\n  const address = getAddressFromPublicKey(issuerPublicKey);\n  if (publicKeyOrAddress === issuerPublicKey) {} else if (publicKeyOrAddress === address) {} else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n  const tokenVerified = tokenVerifier.verify(token);\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n  return decodedToken;\n}\nexport function extractProfile(token, publicKeyOrAddress = null) {\n  let decodedToken;\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n  let profile = {};\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim;\n    }\n  }\n  return profile;\n}","map":{"version":3,"names":["decodeToken","SECP256K1Client","TokenSigner","TokenVerifier","nextYear","makeUUID4","getAddressFromPublicKey","signProfileToken","profile","privateKey","subject","issuer","signingAlgorithm","issuedAt","Date","expiresAt","Error","publicKey","derivePublicKey","tokenSigner","payload","jti","iat","toISOString","exp","claim","sign","wrapProfileToken","token","decodedToken","verifyProfileToken","publicKeyOrAddress","hasOwnProperty","issuerPublicKey","address","tokenVerifier","header","alg","tokenVerified","verify","extractProfile"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\profile\\src\\profileTokens.ts"],"sourcesContent":["import { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\r\nimport { TokenInterface } from 'jsontokens/lib/decode';\r\nimport { nextYear, makeUUID4 } from '@stacks/common';\r\nimport { getAddressFromPublicKey } from '@stacks/transactions';\r\n\r\n/**\r\n * Signs a profile token\r\n * @param {Object} profile - the JSON of the profile to be signed\r\n * @param {String} privateKey - the signing private key\r\n * @param {Object} subject - the entity that the information is about\r\n * @param {Object} issuer - the entity that is issuing the token\r\n * @param {String} signingAlgorithm - the signing algorithm to use\r\n * @param {Date} issuedAt - the time of issuance of the token\r\n * @param {Date} expiresAt - the time of expiration of the token\r\n * @returns {Object} - the signed profile token\r\n *\r\n */\r\nexport function signProfileToken(\r\n  profile: any,\r\n  privateKey: string,\r\n  subject?: any,\r\n  issuer?: any,\r\n  signingAlgorithm = 'ES256K',\r\n  issuedAt = new Date(),\r\n  expiresAt = nextYear()\r\n): string {\r\n  if (signingAlgorithm !== 'ES256K') {\r\n    throw new Error('Signing algorithm not supported');\r\n  }\r\n\r\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\r\n\r\n  if (!subject) {\r\n    subject = { publicKey };\r\n  }\r\n\r\n  if (!issuer) {\r\n    issuer = { publicKey };\r\n  }\r\n\r\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\r\n\r\n  const payload = {\r\n    jti: makeUUID4(),\r\n    iat: issuedAt.toISOString(),\r\n    exp: expiresAt.toISOString(),\r\n    subject,\r\n    issuer,\r\n    claim: profile,\r\n  };\r\n\r\n  return tokenSigner.sign(payload);\r\n}\r\n\r\n/**\r\n * Wraps a token for a profile token file\r\n * @param {String} token - the token to be wrapped\r\n * @returns {Object} - including `token` and `decodedToken`\r\n */\r\nexport function wrapProfileToken(token: string) {\r\n  return {\r\n    token,\r\n    decodedToken: decodeToken(token),\r\n  };\r\n}\r\n\r\n/**\r\n * Verifies a profile token\r\n * @param {String} token - the token to be verified\r\n * @param {String} publicKeyOrAddress - the public key or address of the\r\n *   keypair that is thought to have signed the token\r\n * @returns {Object} - the verified, decoded profile token\r\n * @throws {Error} - throws an error if token verification fails\r\n */\r\nexport function verifyProfileToken(token: string, publicKeyOrAddress: string): TokenInterface {\r\n  const decodedToken = decodeToken(token);\r\n  const payload = decodedToken.payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n\r\n  // Inspect and verify the subject\r\n  if (payload.hasOwnProperty('subject') && payload.subject) {\r\n    if (!payload.subject.hasOwnProperty('publicKey')) {\r\n      throw new Error(\"Token doesn't have a subject public key\");\r\n    }\r\n  } else {\r\n    throw new Error(\"Token doesn't have a subject\");\r\n  }\r\n\r\n  // Inspect and verify the issuer\r\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\r\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\r\n      throw new Error(\"Token doesn't have an issuer public key\");\r\n    }\r\n  } else {\r\n    throw new Error(\"Token doesn't have an issuer\");\r\n  }\r\n\r\n  // Inspect and verify the claim\r\n  if (!payload.hasOwnProperty('claim')) {\r\n    throw new Error(\"Token doesn't have a claim\");\r\n  }\r\n\r\n  const issuerPublicKey = (payload.issuer as Record<string, string>).publicKey;\r\n  const address = getAddressFromPublicKey(issuerPublicKey);\r\n\r\n  if (publicKeyOrAddress === issuerPublicKey) {\r\n    // pass\r\n  } else if (publicKeyOrAddress === address) {\r\n    // pass\r\n  } else {\r\n    throw new Error('Token issuer public key does not match the verifying value');\r\n  }\r\n\r\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg as string, issuerPublicKey);\r\n  if (!tokenVerifier) {\r\n    throw new Error('Invalid token verifier');\r\n  }\r\n\r\n  const tokenVerified = tokenVerifier.verify(token);\r\n  if (!tokenVerified) {\r\n    throw new Error('Token verification failed');\r\n  }\r\n\r\n  return decodedToken;\r\n}\r\n\r\n/**\r\n * Extracts a profile from an encoded token and optionally verifies it,\r\n * if `publicKeyOrAddress` is provided.\r\n * @param {String} token - the token to be extracted\r\n * @param {String} publicKeyOrAddress - the public key or address of the\r\n *   keypair that is thought to have signed the token\r\n * @returns {Object} - the profile extracted from the encoded token\r\n * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\r\n */\r\nexport function extractProfile(\r\n  token: string,\r\n  publicKeyOrAddress: string | null = null\r\n): Record<string, any> {\r\n  let decodedToken;\r\n  if (publicKeyOrAddress) {\r\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\r\n  } else {\r\n    decodedToken = decodeToken(token);\r\n  }\r\n\r\n  let profile = {};\r\n  if (decodedToken.hasOwnProperty('payload')) {\r\n    const payload = decodedToken.payload;\r\n    if (typeof payload === 'string') {\r\n      throw new Error('Unexpected token payload type of string');\r\n    }\r\n    if (payload.hasOwnProperty('claim')) {\r\n      profile = payload.claim as Record<string, any>;\r\n    }\r\n  }\r\n\r\n  return profile;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}