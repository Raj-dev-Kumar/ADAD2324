{"ast":null,"code":"import { bytesToHex, concatArray, hexToBytes, intToBigInt, intToBytes, writeUInt16BE } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { serializeMessageSignature, deserializeMessageSignature } from './signature';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { createStacksPublicKey, getPublicKey, isCompressed, publicKeyFromSignatureVrs, signWithKey } from './keys';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))\n  };\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\nfunction clearCondition(condition) {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  };\n}\nexport function serializeSingleSigSpendingCondition(condition) {\n  const bytesArray = [condition.hashMode, hexToBytes(condition.signer), intToBytes(condition.nonce, false, 8), intToBytes(condition.fee, false, 8), condition.keyEncoding, serializeMessageSignature(condition.signature)];\n  return concatArray(bytesArray);\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  const bytesArray = [condition.hashMode, hexToBytes(condition.signer), intToBytes(condition.nonce, false, 8), intToBytes(condition.fee, false, 8)];\n  const fields = createLPList(condition.fields);\n  bytesArray.push(serializeLPList(fields));\n  const numSigs = new Uint8Array(2);\n  writeUInt16BE(numSigs, condition.signaturesRequired, 0);\n  bytesArray.push(numSigs);\n  return concatArray(bytesArray);\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');\n  }\n  const signature = deserializeMessageSignature(bytesReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  const fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField).values;\n  let haveUncompressed = false;\n  let numSigs = 0;\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Failed to parse multisig spending condition: too many signatures');\n        break;\n    }\n  }\n  const signaturesRequired = bytesReader.readUInt16BE();\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  }\n  return serializeMultiSigSpendingCondition(condition);\n}\nexport function deserializeSpendingCondition(bytesReader) {\n  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  const hashLength = 32 + 1 + 8 + 8;\n  const sigHash = curSigHash + bytesToHex(new Uint8Array([authType])) + bytesToHex(intToBytes(fee, false, 8)) + bytesToHex(intToBytes(nonce, false, 8));\n  if (hexToBytes(sigHash).byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n  return txidFromData(hexToBytes(sigHash));\n}\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  const pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  const sigHashBytes = hexToBytes(sigHash);\n  if (sigHashBytes.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n  return txidFromData(sigHashBytes);\n}\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  const publicKey = createStacksPublicKey(publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding));\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash\n  };\n}\nfunction newInitialSigHash() {\n  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  const {\n    pubKey,\n    nextSigHash\n  } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return nextSigHash;\n}\nfunction verifyMultiSig(condition, initialSigHash, authType) {\n  const publicKeys = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n  for (const field of condition.fields) {\n    let foundPubKey;\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const {\n          pubKey,\n          nextSigHash\n        } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n        break;\n    }\n    publicKeys.push(foundPubKey);\n  }\n  if (numSigs !== condition.signaturesRequired) throw new VerificationError('Incorrect number of signatures');\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return curSigHash;\n}\nexport function createStandardAuth(spendingCondition) {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition\n  };\n}\nexport function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0)\n  };\n}\nexport function intoInitialSighashAuth(auth) {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n  throw new Error('Authorization missing SpendingCondition');\n}\nexport function verifyOrigin(auth, initialSigHash) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\nexport function setFee(auth, amount) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false)\n      };\n      return {\n        ...auth,\n        spendingCondition\n      };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false)\n      };\n      return {\n        ...auth,\n        sponsorSpendingCondition\n      };\n  }\n}\nexport function getFee(auth) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\nexport function setNonce(auth, nonce) {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false)\n  };\n  return {\n    ...auth,\n    spendingCondition\n  };\n}\nexport function setSponsorNonce(auth, nonce) {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false)\n  };\n  return {\n    ...auth,\n    sponsorSpendingCondition\n  };\n}\nexport function setSponsor(auth, sponsorSpendingCondition) {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false)\n  };\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc\n  };\n}\nexport function serializeAuthorization(auth) {\n  const bytesArray = [];\n  bytesArray.push(auth.authType);\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializeAuthorization(bytesReader) {\n  const authType = bytesReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}","map":{"version":3,"names":["bytesToHex","concatArray","hexToBytes","intToBigInt","intToBytes","writeUInt16BE","AddressHashMode","AuthType","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","cloneDeep","leftPadHex","txidFromData","serializeMessageSignature","deserializeMessageSignature","addressFromPublicKeys","createEmptyAddress","createLPList","deserializeLPList","serializeLPList","createStacksPublicKey","getPublicKey","isCompressed","publicKeyFromSignatureVrs","signWithKey","DeserializationError","SigningError","VerificationError","emptyMessageSignature","type","MessageSignature","data","Uint8Array","createSingleSigSpendingCondition","hashMode","pubKey","nonce","fee","signer","hash160","keyEncoding","Compressed","Uncompressed","signature","createMultiSigSpendingCondition","numSigs","pubKeys","stacksPublicKeys","map","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","BigInt","serializeSingleSigSpendingCondition","bytesArray","serializeMultiSigSpendingCondition","push","deserializeSingleSigSpendingCondition","bytesReader","readBytes","readUInt8Enum","n","SerializeP2WPKH","deserializeMultiSigSpendingCondition","TransactionAuthField","values","haveUncompressed","field","contents","PublicKey","pubKeyEncoding","readUInt16BE","SerializeP2SH","serializeSpendingCondition","deserializeSpendingCondition","SerializeP2PKH","makeSigHashPreSign","curSigHash","authType","hashLength","sigHash","byteLength","Error","makeSigHashPostSign","toString","sigHashBytes","nextSignature","privateKey","sigHashPreSign","publicKey","nextSigHash","nextSig","nextVerification","initialSigHash","newInitialSigHash","spendingCondition","verify","verifySingleSig","verifyMultiSig","addrBytes","publicKeys","foundPubKey","createStandardAuth","Standard","createSponsoredAuth","sponsorSpendingCondition","Sponsored","repeat","intoInitialSighashAuth","auth","verifyOrigin","setFee","amount","getFee","setNonce","setSponsorNonce","setSponsor","sc","serializeAuthorization","deserializeAuthorization"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\authorization.ts"],"sourcesContent":["import {\r\n  bytesToHex,\r\n  concatArray,\r\n  hexToBytes,\r\n  IntegerType,\r\n  intToBigInt,\r\n  intToBytes,\r\n  writeUInt16BE,\r\n} from '@stacks/common';\r\nimport {\r\n  AddressHashMode,\r\n  AuthType,\r\n  MultiSigHashMode,\r\n  PubKeyEncoding,\r\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\r\n  SingleSigHashMode,\r\n  StacksMessageType,\r\n} from './constants';\r\n\r\nimport { cloneDeep, leftPadHex, txidFromData } from './utils';\r\nimport {\r\n  TransactionAuthField,\r\n  serializeMessageSignature,\r\n  deserializeMessageSignature,\r\n} from './signature';\r\nimport {\r\n  addressFromPublicKeys,\r\n  createEmptyAddress,\r\n  createLPList,\r\n  deserializeLPList,\r\n  serializeLPList,\r\n} from './types';\r\n\r\nimport {\r\n  createStacksPublicKey,\r\n  getPublicKey,\r\n  isCompressed,\r\n  publicKeyFromSignatureVrs,\r\n  signWithKey,\r\n  StacksPrivateKey,\r\n  StacksPublicKey,\r\n} from './keys';\r\n\r\nimport { MessageSignature } from './common';\r\nimport { DeserializationError, SigningError, VerificationError } from './errors';\r\nimport { BytesReader } from './bytesReader';\r\n\r\nexport function emptyMessageSignature(): MessageSignature {\r\n  return {\r\n    type: StacksMessageType.MessageSignature,\r\n    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)),\r\n  };\r\n}\r\n\r\nexport interface SingleSigSpendingCondition {\r\n  hashMode: SingleSigHashMode;\r\n  signer: string;\r\n  nonce: bigint;\r\n  fee: bigint;\r\n  keyEncoding: PubKeyEncoding;\r\n  signature: MessageSignature;\r\n}\r\n\r\nexport interface SingleSigSpendingConditionOpts\r\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\r\n  nonce: IntegerType;\r\n  fee: IntegerType;\r\n}\r\n\r\nexport interface MultiSigSpendingCondition {\r\n  hashMode: MultiSigHashMode;\r\n  signer: string;\r\n  nonce: bigint;\r\n  fee: bigint;\r\n  fields: TransactionAuthField[];\r\n  signaturesRequired: number;\r\n}\r\n\r\nexport interface MultiSigSpendingConditionOpts\r\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\r\n  nonce: IntegerType;\r\n  fee: IntegerType;\r\n}\r\n\r\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\r\n\r\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\r\n\r\nexport function createSingleSigSpendingCondition(\r\n  hashMode: SingleSigHashMode,\r\n  pubKey: string,\r\n  nonce: IntegerType,\r\n  fee: IntegerType\r\n): SingleSigSpendingCondition {\r\n  // address version arg doesn't matter for signer hash generation\r\n  const signer = addressFromPublicKeys(\r\n    0 as any, // only used for hash, so version doesn't matter\r\n    hashMode,\r\n    1,\r\n    [createStacksPublicKey(pubKey)]\r\n  ).hash160;\r\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\r\n    ? PubKeyEncoding.Compressed\r\n    : PubKeyEncoding.Uncompressed;\r\n\r\n  return {\r\n    hashMode,\r\n    signer,\r\n    nonce: intToBigInt(nonce, false),\r\n    fee: intToBigInt(fee, false),\r\n    keyEncoding,\r\n    signature: emptyMessageSignature(),\r\n  };\r\n}\r\n\r\nexport function createMultiSigSpendingCondition(\r\n  hashMode: MultiSigHashMode,\r\n  numSigs: number,\r\n  pubKeys: string[],\r\n  nonce: IntegerType,\r\n  fee: IntegerType\r\n): MultiSigSpendingCondition {\r\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\r\n\r\n  // address version arg doesn't matter for signer hash generation\r\n  const signer = addressFromPublicKeys(\r\n    0 as any, // only used for hash, so version doesn't matter\r\n    hashMode,\r\n    numSigs,\r\n    stacksPublicKeys\r\n  ).hash160;\r\n\r\n  return {\r\n    hashMode,\r\n    signer,\r\n    nonce: intToBigInt(nonce, false),\r\n    fee: intToBigInt(fee, false),\r\n    fields: [],\r\n    signaturesRequired: numSigs,\r\n  };\r\n}\r\n\r\nexport function isSingleSig(\r\n  condition: SpendingConditionOpts\r\n): condition is SingleSigSpendingConditionOpts {\r\n  return 'signature' in condition;\r\n}\r\n\r\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\r\n  const cloned = cloneDeep(condition);\r\n  cloned.nonce = 0;\r\n  cloned.fee = 0;\r\n\r\n  if (isSingleSig(cloned)) {\r\n    cloned.signature = emptyMessageSignature();\r\n  } else {\r\n    cloned.fields = [];\r\n  }\r\n\r\n  return {\r\n    ...cloned,\r\n    nonce: BigInt(0),\r\n    fee: BigInt(0),\r\n  };\r\n}\r\n\r\nexport function serializeSingleSigSpendingCondition(\r\n  condition: SingleSigSpendingConditionOpts\r\n): Uint8Array {\r\n  const bytesArray = [\r\n    condition.hashMode,\r\n    hexToBytes(condition.signer),\r\n    intToBytes(condition.nonce, false, 8),\r\n    intToBytes(condition.fee, false, 8),\r\n    condition.keyEncoding as number,\r\n    serializeMessageSignature(condition.signature),\r\n  ];\r\n  return concatArray(bytesArray);\r\n}\r\n\r\nexport function serializeMultiSigSpendingCondition(\r\n  condition: MultiSigSpendingConditionOpts\r\n): Uint8Array {\r\n  const bytesArray = [\r\n    condition.hashMode,\r\n    hexToBytes(condition.signer),\r\n    intToBytes(condition.nonce, false, 8),\r\n    intToBytes(condition.fee, false, 8),\r\n  ];\r\n\r\n  const fields = createLPList(condition.fields);\r\n  bytesArray.push(serializeLPList(fields));\r\n\r\n  const numSigs = new Uint8Array(2);\r\n  writeUInt16BE(numSigs, condition.signaturesRequired, 0);\r\n  bytesArray.push(numSigs);\r\n\r\n  return concatArray(bytesArray);\r\n}\r\n\r\nexport function deserializeSingleSigSpendingCondition(\r\n  hashMode: SingleSigHashMode,\r\n  bytesReader: BytesReader\r\n): SingleSigSpendingCondition {\r\n  const signer = bytesToHex(bytesReader.readBytes(20));\r\n  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\r\n  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\r\n\r\n  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, n => {\r\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\r\n  });\r\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\r\n    throw new DeserializationError(\r\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\r\n    );\r\n  }\r\n  const signature = deserializeMessageSignature(bytesReader);\r\n  return {\r\n    hashMode,\r\n    signer,\r\n    nonce,\r\n    fee,\r\n    keyEncoding,\r\n    signature,\r\n  };\r\n}\r\n\r\nexport function deserializeMultiSigSpendingCondition(\r\n  hashMode: MultiSigHashMode,\r\n  bytesReader: BytesReader\r\n): MultiSigSpendingCondition {\r\n  const signer = bytesToHex(bytesReader.readBytes(20));\r\n  const nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\r\n  const fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\r\n\r\n  const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField)\r\n    .values as TransactionAuthField[];\r\n\r\n  let haveUncompressed = false;\r\n  let numSigs = 0;\r\n\r\n  for (const field of fields) {\r\n    switch (field.contents.type) {\r\n      case StacksMessageType.PublicKey:\r\n        if (!isCompressed(field.contents)) haveUncompressed = true;\r\n        break;\r\n      case StacksMessageType.MessageSignature:\r\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\r\n        numSigs += 1;\r\n        if (numSigs === 65536)\r\n          throw new VerificationError(\r\n            'Failed to parse multisig spending condition: too many signatures'\r\n          );\r\n        break;\r\n    }\r\n  }\r\n  const signaturesRequired = bytesReader.readUInt16BE();\r\n\r\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\r\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\r\n\r\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\r\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\r\n\r\n  return {\r\n    hashMode,\r\n    signer,\r\n    nonce,\r\n    fee,\r\n    fields,\r\n    signaturesRequired,\r\n  };\r\n}\r\n\r\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Uint8Array {\r\n  if (isSingleSig(condition)) {\r\n    return serializeSingleSigSpendingCondition(condition);\r\n  }\r\n  return serializeMultiSigSpendingCondition(condition);\r\n}\r\n\r\nexport function deserializeSpendingCondition(bytesReader: BytesReader): SpendingCondition {\r\n  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, n => {\r\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\r\n  });\r\n\r\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\r\n    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);\r\n  } else {\r\n    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);\r\n  }\r\n}\r\n\r\nexport function makeSigHashPreSign(\r\n  curSigHash: string,\r\n  authType: AuthType,\r\n  fee: IntegerType,\r\n  nonce: IntegerType\r\n): string {\r\n  // new hash combines the previous hash and all the new data this signature will add. This\r\n  // includes:\r\n  // * the previous hash\r\n  // * the auth flag\r\n  // * the tx fee (big-endian 8-byte number)\r\n  // * nonce (big-endian 8-byte number)\r\n  const hashLength = 32 + 1 + 8 + 8;\r\n\r\n  const sigHash =\r\n    curSigHash +\r\n    bytesToHex(new Uint8Array([authType])) +\r\n    bytesToHex(intToBytes(fee, false, 8)) +\r\n    bytesToHex(intToBytes(nonce, false, 8));\r\n\r\n  if (hexToBytes(sigHash).byteLength !== hashLength) {\r\n    throw Error('Invalid signature hash length');\r\n  }\r\n\r\n  return txidFromData(hexToBytes(sigHash));\r\n}\r\n\r\nfunction makeSigHashPostSign(\r\n  curSigHash: string,\r\n  pubKey: StacksPublicKey,\r\n  signature: MessageSignature\r\n): string {\r\n  // new hash combines the previous hash and all the new data this signature will add.  This\r\n  // includes:\r\n  // * the public key compression flag\r\n  // * the signature\r\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\r\n\r\n  const pubKeyEncoding = isCompressed(pubKey)\r\n    ? PubKeyEncoding.Compressed\r\n    : PubKeyEncoding.Uncompressed;\r\n\r\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\r\n\r\n  const sigHashBytes = hexToBytes(sigHash);\r\n  if (sigHashBytes.byteLength > hashLength) {\r\n    throw Error('Invalid signature hash length');\r\n  }\r\n\r\n  return txidFromData(sigHashBytes);\r\n}\r\n\r\nexport function nextSignature(\r\n  curSigHash: string,\r\n  authType: AuthType,\r\n  fee: IntegerType,\r\n  nonce: IntegerType,\r\n  privateKey: StacksPrivateKey\r\n): {\r\n  nextSig: MessageSignature;\r\n  nextSigHash: string;\r\n} {\r\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\r\n\r\n  const signature = signWithKey(privateKey, sigHashPreSign);\r\n  const publicKey = getPublicKey(privateKey);\r\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\r\n\r\n  return {\r\n    nextSig: signature,\r\n    nextSigHash,\r\n  };\r\n}\r\n\r\nexport function nextVerification(\r\n  initialSigHash: string,\r\n  authType: AuthType,\r\n  fee: IntegerType,\r\n  nonce: IntegerType,\r\n  pubKeyEncoding: PubKeyEncoding,\r\n  signature: MessageSignature\r\n) {\r\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\r\n\r\n  const publicKey = createStacksPublicKey(\r\n    publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding)\r\n  );\r\n\r\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\r\n\r\n  return {\r\n    pubKey: publicKey,\r\n    nextSigHash,\r\n  };\r\n}\r\n\r\nfunction newInitialSigHash(): SpendingCondition {\r\n  const spendingCondition = createSingleSigSpendingCondition(\r\n    AddressHashMode.SerializeP2PKH,\r\n    '',\r\n    0,\r\n    0\r\n  );\r\n  spendingCondition.signer = createEmptyAddress().hash160;\r\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\r\n  spendingCondition.signature = emptyMessageSignature();\r\n  return spendingCondition;\r\n}\r\n\r\nfunction verify(\r\n  condition: SpendingConditionOpts,\r\n  initialSigHash: string,\r\n  authType: AuthType\r\n): string {\r\n  if (isSingleSig(condition)) {\r\n    return verifySingleSig(condition, initialSigHash, authType);\r\n  } else {\r\n    return verifyMultiSig(condition, initialSigHash, authType);\r\n  }\r\n}\r\n\r\nfunction verifySingleSig(\r\n  condition: SingleSigSpendingConditionOpts,\r\n  initialSigHash: string,\r\n  authType: AuthType\r\n): string {\r\n  const { pubKey, nextSigHash } = nextVerification(\r\n    initialSigHash,\r\n    authType,\r\n    condition.fee,\r\n    condition.nonce,\r\n    condition.keyEncoding,\r\n    condition.signature\r\n  );\r\n\r\n  // address version arg doesn't matter for signer hash generation\r\n  const addrBytes = addressFromPublicKeys(\r\n    0 as any, // only used for hash, so version doesn't matter\r\n    condition.hashMode,\r\n    1,\r\n    [pubKey]\r\n  ).hash160;\r\n\r\n  if (addrBytes !== condition.signer)\r\n    throw new VerificationError(\r\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\r\n    );\r\n\r\n  return nextSigHash;\r\n}\r\n\r\nfunction verifyMultiSig(\r\n  condition: MultiSigSpendingConditionOpts,\r\n  initialSigHash: string,\r\n  authType: AuthType\r\n): string {\r\n  const publicKeys: StacksPublicKey[] = [];\r\n  let curSigHash = initialSigHash;\r\n  let haveUncompressed = false;\r\n  let numSigs = 0;\r\n\r\n  for (const field of condition.fields) {\r\n    let foundPubKey: StacksPublicKey;\r\n\r\n    switch (field.contents.type) {\r\n      case StacksMessageType.PublicKey:\r\n        if (!isCompressed(field.contents)) haveUncompressed = true;\r\n        foundPubKey = field.contents;\r\n        break;\r\n      case StacksMessageType.MessageSignature:\r\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\r\n        const { pubKey, nextSigHash } = nextVerification(\r\n          curSigHash,\r\n          authType,\r\n          condition.fee,\r\n          condition.nonce,\r\n          field.pubKeyEncoding,\r\n          field.contents\r\n        );\r\n        curSigHash = nextSigHash;\r\n        foundPubKey = pubKey;\r\n\r\n        numSigs += 1;\r\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\r\n\r\n        break;\r\n    }\r\n    publicKeys.push(foundPubKey);\r\n  }\r\n\r\n  if (numSigs !== condition.signaturesRequired)\r\n    throw new VerificationError('Incorrect number of signatures');\r\n\r\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\r\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\r\n\r\n  const addrBytes = addressFromPublicKeys(\r\n    0 as any, // only used for hash, so version doesn't matter\r\n    condition.hashMode,\r\n    condition.signaturesRequired,\r\n    publicKeys\r\n  ).hash160;\r\n  if (addrBytes !== condition.signer)\r\n    throw new VerificationError(\r\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\r\n    );\r\n\r\n  return curSigHash;\r\n}\r\n\r\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\r\n\r\nexport interface StandardAuthorization {\r\n  authType: AuthType.Standard;\r\n  spendingCondition: SpendingCondition;\r\n}\r\n\r\nexport interface SponsoredAuthorization {\r\n  authType: AuthType.Sponsored;\r\n  spendingCondition: SpendingCondition;\r\n  sponsorSpendingCondition: SpendingCondition;\r\n}\r\n\r\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\r\n  return {\r\n    authType: AuthType.Standard,\r\n    spendingCondition,\r\n  };\r\n}\r\n\r\nexport function createSponsoredAuth(\r\n  spendingCondition: SpendingCondition,\r\n  sponsorSpendingCondition?: SpendingCondition\r\n): Authorization {\r\n  return {\r\n    authType: AuthType.Sponsored,\r\n    spendingCondition,\r\n    sponsorSpendingCondition: sponsorSpendingCondition\r\n      ? sponsorSpendingCondition\r\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\r\n  };\r\n}\r\n\r\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\r\n  if (auth.spendingCondition) {\r\n    switch (auth.authType) {\r\n      case AuthType.Standard:\r\n        return createStandardAuth(clearCondition(auth.spendingCondition));\r\n      case AuthType.Sponsored:\r\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\r\n      default:\r\n        throw new SigningError('Unexpected authorization type for signing');\r\n    }\r\n  }\r\n\r\n  throw new Error('Authorization missing SpendingCondition');\r\n}\r\n\r\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\r\n  switch (auth.authType) {\r\n    case AuthType.Standard:\r\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\r\n    case AuthType.Sponsored:\r\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\r\n    default:\r\n      throw new SigningError('Invalid origin auth type');\r\n  }\r\n}\r\n\r\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\r\n  switch (auth.authType) {\r\n    case AuthType.Standard:\r\n      const spendingCondition = {\r\n        ...auth.spendingCondition,\r\n        fee: intToBigInt(amount, false),\r\n      };\r\n      return { ...auth, spendingCondition };\r\n    case AuthType.Sponsored:\r\n      const sponsorSpendingCondition = {\r\n        ...auth.sponsorSpendingCondition,\r\n        fee: intToBigInt(amount, false),\r\n      };\r\n      return { ...auth, sponsorSpendingCondition };\r\n  }\r\n}\r\n\r\nexport function getFee(auth: Authorization): bigint {\r\n  switch (auth.authType) {\r\n    case AuthType.Standard:\r\n      return auth.spendingCondition.fee;\r\n    case AuthType.Sponsored:\r\n      return auth.sponsorSpendingCondition.fee;\r\n  }\r\n}\r\n\r\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\r\n  const spendingCondition = {\r\n    ...auth.spendingCondition,\r\n    nonce: intToBigInt(nonce, false),\r\n  };\r\n\r\n  return {\r\n    ...auth,\r\n    spendingCondition,\r\n  };\r\n}\r\n\r\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\r\n  const sponsorSpendingCondition = {\r\n    ...auth.sponsorSpendingCondition,\r\n    nonce: intToBigInt(nonce, false),\r\n  };\r\n\r\n  return {\r\n    ...auth,\r\n    sponsorSpendingCondition,\r\n  };\r\n}\r\n\r\nexport function setSponsor(\r\n  auth: SponsoredAuthorization,\r\n  sponsorSpendingCondition: SpendingConditionOpts\r\n): Authorization {\r\n  const sc = {\r\n    ...sponsorSpendingCondition,\r\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\r\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\r\n  };\r\n\r\n  return {\r\n    ...auth,\r\n    sponsorSpendingCondition: sc,\r\n  };\r\n}\r\n\r\nexport function serializeAuthorization(auth: Authorization): Uint8Array {\r\n  const bytesArray = [];\r\n  bytesArray.push(auth.authType);\r\n\r\n  switch (auth.authType) {\r\n    case AuthType.Standard:\r\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\r\n      break;\r\n    case AuthType.Sponsored:\r\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\r\n      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\r\n      break;\r\n  }\r\n\r\n  return concatArray(bytesArray);\r\n}\r\n\r\nexport function deserializeAuthorization(bytesReader: BytesReader) {\r\n  const authType = bytesReader.readUInt8Enum(AuthType, n => {\r\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\r\n  });\r\n\r\n  let spendingCondition;\r\n  switch (authType) {\r\n    case AuthType.Standard:\r\n      spendingCondition = deserializeSpendingCondition(bytesReader);\r\n      return createStandardAuth(spendingCondition);\r\n    case AuthType.Sponsored:\r\n      spendingCondition = deserializeSpendingCondition(bytesReader);\r\n      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);\r\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}