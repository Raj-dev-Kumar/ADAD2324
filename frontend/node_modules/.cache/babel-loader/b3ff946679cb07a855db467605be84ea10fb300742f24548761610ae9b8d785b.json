{"ast":null,"code":"import { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nimport { randomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nimport { bytesToHex, bytesToUtf8, concatBytes, equals, hexToBytes, utf8ToBytes } from '@stacks/common';\nimport { hmacSha256 } from './ec';\nexport async function encryptMnemonic(phrase, password, opts) {\n  let mnemonicEntropy;\n  try {\n    const entropyBytes = mnemonicToEntropy(phrase, wordlist);\n    mnemonicEntropy = bytesToHex(entropyBytes);\n  } catch (error) {\n    console.error('Invalid mnemonic phrase provided');\n    console.error(error);\n    throw new Error('Not a valid bip39 mnemonic');\n  }\n  const plaintextNormalized = hexToBytes(mnemonicEntropy);\n  const pbkdf2 = await createPbkdf2();\n  const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : randomBytes(16);\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const cipher = await createCipher();\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n  const hmacPayload = concatBytes(salt, cipherText);\n  const hmacDigest = hmacSha256(macKey, hmacPayload);\n  const payload = concatBytes(salt, hmacDigest, cipherText);\n  return payload;\n}\nclass PasswordError extends Error {}\nasync function decryptMnemonicBytes(dataBytes, password) {\n  const salt = dataBytes.slice(0, 16);\n  const hmacSig = dataBytes.slice(16, 48);\n  const cipherText = dataBytes.slice(48);\n  const hmacPayload = concatBytes(salt, cipherText);\n  const pbkdf2 = await createPbkdf2();\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const decipher = await createCipher();\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n  const hmacDigest = hmacSha256(macKey, hmacPayload);\n  const sha2Hash = await createSha2Hash();\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n  if (!equals(hmacSigHash, hmacDigestHash)) {\n    throw new PasswordError('Wrong password (HMAC mismatch)');\n  }\n  let mnemonic;\n  try {\n    mnemonic = entropyToMnemonic(decryptedResult, wordlist);\n  } catch (error) {\n    console.error('Error thrown by `entropyToMnemonic`');\n    console.error(error);\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n  if (!validateMnemonic(mnemonic, wordlist)) {\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n  return mnemonic;\n}\nfunction decryptLegacy(dataBytes, password, triplesecDecrypt) {\n  return new Promise((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n    triplesecDecrypt({\n      key: utf8ToBytes(password),\n      data: dataBytes\n    }, (err, plaintextBytes) => {\n      if (!err) {\n        resolve(plaintextBytes);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\nexport async function decryptMnemonic(data, password, triplesecDecrypt) {\n  const dataBytes = typeof data === 'string' ? hexToBytes(data) : data;\n  try {\n    return await decryptMnemonicBytes(dataBytes, password);\n  } catch (error) {\n    if (error instanceof PasswordError) throw error;\n    const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);\n    return bytesToUtf8(data);\n  }\n}","map":{"version":3,"names":["validateMnemonic","mnemonicToEntropy","entropyToMnemonic","wordlist","randomBytes","createSha2Hash","createCipher","createPbkdf2","bytesToHex","bytesToUtf8","concatBytes","equals","hexToBytes","utf8ToBytes","hmacSha256","encryptMnemonic","phrase","password","opts","mnemonicEntropy","entropyBytes","error","console","Error","plaintextNormalized","pbkdf2","salt","getRandomBytes","keysAndIV","derive","encKey","slice","macKey","iv","cipher","cipherText","encrypt","hmacPayload","hmacDigest","payload","PasswordError","decryptMnemonicBytes","dataBytes","hmacSig","decipher","decryptedResult","decrypt","sha2Hash","hmacSigHash","digest","hmacDigestHash","mnemonic","decryptLegacy","triplesecDecrypt","Promise","resolve","reject","key","data","err","plaintextBytes","decryptMnemonic"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\encryption\\src\\wallet.ts"],"sourcesContent":["// https://github.com/paulmillr/scure-bip39\r\n// Secure, audited & minimal implementation of BIP39 mnemonic phrases.\r\nimport { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from '@scure/bip39';\r\n// Word lists not imported by default as that would increase bundle sizes too much as in case of bitcoinjs/bip39\r\n// Use default english world list similiar to bitcoinjs/bip39\r\n// Backward compatible with bitcoinjs/bip39 dependency\r\n// Very small in size as compared to bitcoinjs/bip39 wordlist\r\n// Reference: https://github.com/paulmillr/scure-bip39\r\nimport { wordlist } from '@scure/bip39/wordlists/english';\r\nimport { randomBytes, GetRandomBytes } from './cryptoRandom';\r\nimport { createSha2Hash } from './sha2Hash';\r\nimport { createCipher } from './aesCipher';\r\nimport { createPbkdf2 } from './pbkdf2';\r\nimport { TriplesecDecryptSignature } from './cryptoUtils';\r\nimport {\r\n  bytesToHex,\r\n  bytesToUtf8,\r\n  concatBytes,\r\n  equals,\r\n  hexToBytes,\r\n  utf8ToBytes,\r\n} from '@stacks/common';\r\nimport { hmacSha256 } from './ec';\r\n\r\n/**\r\n * Encrypt a raw mnemonic phrase to be password protected\r\n * @param {string} phrase - Raw mnemonic phrase\r\n * @param {string} password - Password to encrypt mnemonic with\r\n * @return {Promise<Uint8Array>} The encrypted phrase\r\n * @ignore\r\n * */\r\nexport async function encryptMnemonic(\r\n  phrase: string,\r\n  password: string,\r\n  opts?: {\r\n    getRandomBytes?: GetRandomBytes;\r\n  }\r\n): Promise<Uint8Array> {\r\n  // hex encoded mnemonic string\r\n  let mnemonicEntropy: string;\r\n  try {\r\n    // must be bip39 mnemonic\r\n    // `mnemonicToEntropy` converts mnemonic string to raw entropy in form of byte array\r\n    const entropyBytes = mnemonicToEntropy(phrase, wordlist);\r\n    // Convert byte array to hex string\r\n    mnemonicEntropy = bytesToHex(entropyBytes);\r\n  } catch (error) {\r\n    console.error('Invalid mnemonic phrase provided');\r\n    console.error(error);\r\n    throw new Error('Not a valid bip39 mnemonic');\r\n  }\r\n\r\n  // normalize plaintext to fixed length byte string\r\n  const plaintextNormalized = hexToBytes(mnemonicEntropy);\r\n\r\n  // AES-128-CBC with SHA256 HMAC\r\n  const pbkdf2 = await createPbkdf2();\r\n  const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : randomBytes(16);\r\n  const keysAndIV = await pbkdf2.derive(password, salt, 100_000, 48, 'sha512');\r\n  const encKey = keysAndIV.slice(0, 16);\r\n  const macKey = keysAndIV.slice(16, 32);\r\n  const iv = keysAndIV.slice(32, 48);\r\n\r\n  const cipher = await createCipher();\r\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\r\n\r\n  const hmacPayload = concatBytes(salt, cipherText);\r\n  const hmacDigest = hmacSha256(macKey, hmacPayload);\r\n\r\n  const payload = concatBytes(salt, hmacDigest, cipherText);\r\n  return payload;\r\n}\r\n\r\n// Used to distinguish bad password during decrypt vs invalid format\r\nclass PasswordError extends Error {}\r\n\r\n/**\r\n * @ignore\r\n */\r\nasync function decryptMnemonicBytes(dataBytes: Uint8Array, password: string): Promise<string> {\r\n  const salt = dataBytes.slice(0, 16);\r\n  const hmacSig = dataBytes.slice(16, 48); // 32 bytes\r\n  const cipherText = dataBytes.slice(48);\r\n  const hmacPayload = concatBytes(salt, cipherText);\r\n\r\n  const pbkdf2 = await createPbkdf2();\r\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\r\n  const encKey = keysAndIV.slice(0, 16);\r\n  const macKey = keysAndIV.slice(16, 32);\r\n  const iv = keysAndIV.slice(32, 48);\r\n\r\n  const decipher = await createCipher();\r\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\r\n\r\n  const hmacDigest = hmacSha256(macKey, hmacPayload);\r\n\r\n  // hash both hmacSig and hmacDigest so string comparison time\r\n  // is uncorrelated to the ciphertext\r\n  const sha2Hash = await createSha2Hash();\r\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\r\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\r\n\r\n  if (!equals(hmacSigHash, hmacDigestHash)) {\r\n    // not authentic\r\n    throw new PasswordError('Wrong password (HMAC mismatch)');\r\n  }\r\n\r\n  let mnemonic: string;\r\n  try {\r\n    // Converts raw entropy in form of byte array to mnemonic string\r\n    mnemonic = entropyToMnemonic(decryptedResult, wordlist);\r\n  } catch (error) {\r\n    console.error('Error thrown by `entropyToMnemonic`');\r\n    console.error(error);\r\n    throw new PasswordError('Wrong password (invalid plaintext)');\r\n  }\r\n  // Validates mnemonic for being 12-24 words contained in `wordlist`\r\n  if (!validateMnemonic(mnemonic, wordlist)) {\r\n    throw new PasswordError('Wrong password (invalid plaintext)');\r\n  }\r\n\r\n  return mnemonic;\r\n}\r\n\r\n/**\r\n * Decrypt legacy triplesec keys\r\n * @param {Uint8Array} dataBytes - The encrypted key\r\n * @param {String} password - Password for data\r\n * @return {Promise<BuUint8Arrayffer>} Decrypted seed\r\n * @ignore\r\n */\r\nfunction decryptLegacy(\r\n  dataBytes: Uint8Array,\r\n  password: string,\r\n  triplesecDecrypt?: TriplesecDecryptSignature\r\n): Promise<Uint8Array> {\r\n  return new Promise<Uint8Array>((resolve, reject) => {\r\n    if (!triplesecDecrypt) {\r\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\r\n    }\r\n    triplesecDecrypt!(\r\n      {\r\n        key: utf8ToBytes(password),\r\n        data: dataBytes,\r\n      },\r\n      (err, plaintextBytes) => {\r\n        if (!err) {\r\n          resolve(plaintextBytes!);\r\n        } else {\r\n          reject(err);\r\n        }\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Decrypt an encrypted mnemonic phrase with a password.\r\n * Legacy triplesec encrypted payloads are also supported.\r\n * @param data - Bytes or hex-encoded string of the encrypted mnemonic\r\n * @param password - Password for data\r\n * @return {string} the raw mnemonic phrase\r\n * @ignore\r\n */\r\nexport async function decryptMnemonic(\r\n  data: string | Uint8Array,\r\n  password: string,\r\n  triplesecDecrypt?: TriplesecDecryptSignature\r\n): Promise<string> {\r\n  const dataBytes = typeof data === 'string' ? hexToBytes(data) : data;\r\n  try {\r\n    return await decryptMnemonicBytes(dataBytes, password);\r\n  } catch (error) {\r\n    if (error instanceof PasswordError) throw error;\r\n    const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);\r\n    return bytesToUtf8(data);\r\n  }\r\n}\r\n"],"mappings":"AAEA,SAASA,gBAAgB,EAAEC,iBAAiB,EAAEC,iBAAiB,QAAQ,cAAc;AAMrF,SAASC,QAAQ,QAAQ,gCAAgC;AACzD,SAASC,WAAW,QAAwB,gBAAgB;AAC5D,SAASC,cAAc,QAAQ,YAAY;AAC3C,SAASC,YAAY,QAAQ,aAAa;AAC1C,SAASC,YAAY,QAAQ,UAAU;AAEvC,SACEC,UAAU,EACVC,WAAW,EACXC,WAAW,EACXC,MAAM,EACNC,UAAU,EACVC,WAAW,QACN,gBAAgB;AACvB,SAASC,UAAU,QAAQ,MAAM;AASjC,OAAO,eAAeC,eAAeA,CACnCC,MAAc,EACdC,QAAgB,EAChBC,IAEC;EAGD,IAAIC,eAAuB;EAC3B,IAAI;IAGF,MAAMC,YAAY,GAAGnB,iBAAiB,CAACe,MAAM,EAAEb,QAAQ,CAAC;IAExDgB,eAAe,GAAGX,UAAU,CAACY,YAAY,CAAC;GAC3C,CAAC,OAAOC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAC;IACjDC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;IACpB,MAAM,IAAIE,KAAK,CAAC,4BAA4B,CAAC;;EAI/C,MAAMC,mBAAmB,GAAGZ,UAAU,CAACO,eAAe,CAAC;EAGvD,MAAMM,MAAM,GAAG,MAAMlB,YAAY,EAAE;EACnC,MAAMmB,IAAI,GAAGR,IAAI,EAAES,cAAc,GAAGT,IAAI,CAACS,cAAc,CAAC,EAAE,CAAC,GAAGvB,WAAW,CAAC,EAAE,CAAC;EAC7E,MAAMwB,SAAS,GAAG,MAAMH,MAAM,CAACI,MAAM,CAACZ,QAAQ,EAAES,IAAI,EAAE,MAAO,EAAE,EAAE,EAAE,QAAQ,CAAC;EAC5E,MAAMI,MAAM,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACrC,MAAMC,MAAM,GAAGJ,SAAS,CAACG,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EACtC,MAAME,EAAE,GAAGL,SAAS,CAACG,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAElC,MAAMG,MAAM,GAAG,MAAM5B,YAAY,EAAE;EACnC,MAAM6B,UAAU,GAAG,MAAMD,MAAM,CAACE,OAAO,CAAC,aAAa,EAAEN,MAAM,EAAEG,EAAE,EAAET,mBAAmB,CAAC;EAEvF,MAAMa,WAAW,GAAG3B,WAAW,CAACgB,IAAI,EAAES,UAAU,CAAC;EACjD,MAAMG,UAAU,GAAGxB,UAAU,CAACkB,MAAM,EAAEK,WAAW,CAAC;EAElD,MAAME,OAAO,GAAG7B,WAAW,CAACgB,IAAI,EAAEY,UAAU,EAAEH,UAAU,CAAC;EACzD,OAAOI,OAAO;AAChB;AAGA,MAAMC,aAAc,SAAQjB,KAAK;AAKjC,eAAekB,oBAAoBA,CAACC,SAAqB,EAAEzB,QAAgB;EACzE,MAAMS,IAAI,GAAGgB,SAAS,CAACX,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACnC,MAAMY,OAAO,GAAGD,SAAS,CAACX,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EACvC,MAAMI,UAAU,GAAGO,SAAS,CAACX,KAAK,CAAC,EAAE,CAAC;EACtC,MAAMM,WAAW,GAAG3B,WAAW,CAACgB,IAAI,EAAES,UAAU,CAAC;EAEjD,MAAMV,MAAM,GAAG,MAAMlB,YAAY,EAAE;EACnC,MAAMqB,SAAS,GAAG,MAAMH,MAAM,CAACI,MAAM,CAACZ,QAAQ,EAAES,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,QAAQ,CAAC;EAC3E,MAAMI,MAAM,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EACrC,MAAMC,MAAM,GAAGJ,SAAS,CAACG,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EACtC,MAAME,EAAE,GAAGL,SAAS,CAACG,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAElC,MAAMa,QAAQ,GAAG,MAAMtC,YAAY,EAAE;EACrC,MAAMuC,eAAe,GAAG,MAAMD,QAAQ,CAACE,OAAO,CAAC,aAAa,EAAEhB,MAAM,EAAEG,EAAE,EAAEE,UAAU,CAAC;EAErF,MAAMG,UAAU,GAAGxB,UAAU,CAACkB,MAAM,EAAEK,WAAW,CAAC;EAIlD,MAAMU,QAAQ,GAAG,MAAM1C,cAAc,EAAE;EACvC,MAAM2C,WAAW,GAAG,MAAMD,QAAQ,CAACE,MAAM,CAACN,OAAO,CAAC;EAClD,MAAMO,cAAc,GAAG,MAAMH,QAAQ,CAACE,MAAM,CAACX,UAAU,CAAC;EAExD,IAAI,CAAC3B,MAAM,CAACqC,WAAW,EAAEE,cAAc,CAAC,EAAE;IAExC,MAAM,IAAIV,aAAa,CAAC,gCAAgC,CAAC;;EAG3D,IAAIW,QAAgB;EACpB,IAAI;IAEFA,QAAQ,GAAGjD,iBAAiB,CAAC2C,eAAe,EAAE1C,QAAQ,CAAC;GACxD,CAAC,OAAOkB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,qCAAqC,CAAC;IACpDC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;IACpB,MAAM,IAAImB,aAAa,CAAC,oCAAoC,CAAC;;EAG/D,IAAI,CAACxC,gBAAgB,CAACmD,QAAQ,EAAEhD,QAAQ,CAAC,EAAE;IACzC,MAAM,IAAIqC,aAAa,CAAC,oCAAoC,CAAC;;EAG/D,OAAOW,QAAQ;AACjB;AASA,SAASC,aAAaA,CACpBV,SAAqB,EACrBzB,QAAgB,EAChBoC,gBAA4C;EAE5C,OAAO,IAAIC,OAAO,CAAa,CAACC,OAAO,EAAEC,MAAM,KAAI;IACjD,IAAI,CAACH,gBAAgB,EAAE;MACrBG,MAAM,CAAC,IAAIjC,KAAK,CAAC,mDAAmD,CAAC,CAAC;;IAExE8B,gBAAiB,CACf;MACEI,GAAG,EAAE5C,WAAW,CAACI,QAAQ,CAAC;MAC1ByC,IAAI,EAAEhB;KACP,EACD,CAACiB,GAAG,EAAEC,cAAc,KAAI;MACtB,IAAI,CAACD,GAAG,EAAE;QACRJ,OAAO,CAACK,cAAe,CAAC;OACzB,MAAM;QACLJ,MAAM,CAACG,GAAG,CAAC;;IAEf,CAAC,CACF;EACH,CAAC,CAAC;AACJ;AAUA,OAAO,eAAeE,eAAeA,CACnCH,IAAyB,EACzBzC,QAAgB,EAChBoC,gBAA4C;EAE5C,MAAMX,SAAS,GAAG,OAAOgB,IAAI,KAAK,QAAQ,GAAG9C,UAAU,CAAC8C,IAAI,CAAC,GAAGA,IAAI;EACpE,IAAI;IACF,OAAO,MAAMjB,oBAAoB,CAACC,SAAS,EAAEzB,QAAQ,CAAC;GACvD,CAAC,OAAOI,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYmB,aAAa,EAAE,MAAMnB,KAAK;IAC/C,MAAMqC,IAAI,GAAG,MAAMN,aAAa,CAACV,SAAS,EAAEzB,QAAQ,EAAEoC,gBAAgB,CAAC;IACvE,OAAO5C,WAAW,CAACiD,IAAI,CAAC;;AAE5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}