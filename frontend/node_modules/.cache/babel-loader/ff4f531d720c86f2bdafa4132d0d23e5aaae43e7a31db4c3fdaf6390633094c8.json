{"ast":null,"code":"import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { deserializeCV, serializeCV } from './clarity';\nexport { verify as verifySignature } from '@noble/secp256k1';\nexport var randomBytes = function randomBytes(bytesLength) {\n  return utils.randomBytes(bytesLength);\n};\nexport var leftPadHex = function leftPadHex(hexString) {\n  return hexString.length % 2 == 0 ? hexString : \"0\".concat(hexString);\n};\nexport var leftPadHexToLength = function leftPadHexToLength(hexString, length) {\n  return hexString.padStart(length, '0');\n};\nexport var rightPadHexToLength = function rightPadHexToLength(hexString, length) {\n  return hexString.padEnd(length, '0');\n};\nexport var exceedsMaxLengthBytes = function exceedsMaxLengthBytes(string, maxLengthBytes) {\n  return string ? utf8ToBytes(string).length > maxLengthBytes : false;\n};\nexport function cloneDeep(obj) {\n  return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n  var clone = cloneDeep(obj);\n  delete clone[prop];\n  return clone;\n}\nexport var txidFromData = function txidFromData(data) {\n  return bytesToHex(sha512_256(data));\n};\nexport var hash160 = function hash160(input) {\n  return ripemd160(sha256(input));\n};\nexport var hashP2PKH = function hashP2PKH(input) {\n  return bytesToHex(hash160(input));\n};\nexport var hashP2WPKH = function hashP2WPKH(input) {\n  var keyHash = hash160(input);\n  var redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\n  var redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport var hashP2SH = function hashP2SH(numSigs, pubKeys) {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n  var bytesArray = [];\n  bytesArray.push(80 + numSigs);\n  pubKeys.forEach(function (pubKey) {\n    bytesArray.push(pubKey.length);\n    bytesArray.push(pubKey);\n  });\n  bytesArray.push(80 + pubKeys.length);\n  bytesArray.push(174);\n  var redeemScript = concatArray(bytesArray);\n  var redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport var hashP2WSH = function hashP2WSH(numSigs, pubKeys) {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n  var scriptArray = [];\n  scriptArray.push(80 + numSigs);\n  pubKeys.forEach(function (pubKey) {\n    scriptArray.push(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  scriptArray.push(80 + pubKeys.length);\n  scriptArray.push(174);\n  var script = concatArray(scriptArray);\n  var digest = sha256(script);\n  var bytesArray = [];\n  bytesArray.push(0);\n  bytesArray.push(digest.length);\n  bytesArray.push(digest);\n  var redeemScript = concatArray(bytesArray);\n  var redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\nexport function isClarityName(name) {\n  var regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\nexport function cvToHex(cv) {\n  var serialized = serializeCV(cv);\n  return \"0x\".concat(bytesToHex(serialized));\n}\nexport function hexToCV(hex) {\n  return deserializeCV(hex);\n}\nexport var parseReadOnlyResponse = function parseReadOnlyResponse(response) {\n  if (response.okay) return hexToCV(response.result);\n  throw new Error(response.cause);\n};\nexport var validateStacksAddress = function validateStacksAddress(stacksAddress) {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexport var validateTxId = function validateTxId(txid) {\n  if (txid === 'success') return true;\n  var value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};","map":{"version":3,"names":["ripemd160","sha256","sha512_256","utils","bytesToHex","concatArray","concatBytes","utf8ToBytes","with0x","c32addressDecode","lodashCloneDeep","deserializeCV","serializeCV","verify","verifySignature","randomBytes","bytesLength","leftPadHex","hexString","length","concat","leftPadHexToLength","padStart","rightPadHexToLength","padEnd","exceedsMaxLengthBytes","string","maxLengthBytes","cloneDeep","obj","omit","prop","clone","txidFromData","data","hash160","input","hashP2PKH","hashP2WPKH","keyHash","redeemScript","Uint8Array","redeemScriptHash","hashP2SH","numSigs","pubKeys","Error","bytesArray","push","forEach","pubKey","hashP2WSH","scriptArray","script","digest","isClarityName","name","regex","test","cvToHex","cv","serialized","hexToCV","hex","parseReadOnlyResponse","response","okay","result","cause","validateStacksAddress","stacksAddress","e","validateTxId","txid","value","toLowerCase","BigInt","toString"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\utils.ts"],"sourcesContent":["import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\n\n// Export verify as utility method for signature verification\nexport { verify as verifySignature } from '@noble/secp256k1';\n\n/**\n * Use utils.randomBytes to replace randombytes dependency\n * Generates random bytes of given length\n * @param {number} bytesLength an optional bytes length, default is 32 bytes\n */\nexport const randomBytes = (bytesLength?: number): Uint8Array => utils.randomBytes(bytesLength);\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? utf8ToBytes(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport const txidFromData = (data: Uint8Array): string => {\n  return bytesToHex(sha512_256(data));\n};\n\nexport const hash160 = (input: Uint8Array): Uint8Array => {\n  return ripemd160(sha256(input));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Uint8Array): string => {\n  return bytesToHex(hash160(input));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address over p2sh (p2h-p2wpkh)\nexport const hashP2WPKH = (input: Uint8Array): string => {\n  const keyHash = hash160(input);\n  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Uint8Array[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bytesArray = [];\n  // OP_n\n  bytesArray.push(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bytesArray.push(pubKey.length);\n    bytesArray.push(pubKey);\n  });\n  // OP_m\n  bytesArray.push(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bytesArray.push(174);\n\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multisig address over p2sh (p2sh-p2wsh)\nexport const hashP2WSH = (numSigs: number, pubKeys: Uint8Array[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const scriptArray = [];\n  // OP_n\n  scriptArray.push(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    scriptArray.push(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  // OP_m\n  scriptArray.push(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  scriptArray.push(174);\n\n  const script = concatArray(scriptArray);\n  const digest = sha256(script);\n\n  const bytesArray = [];\n  bytesArray.push(0);\n  bytesArray.push(digest.length);\n  bytesArray.push(digest);\n\n  const redeemScript = concatArray(bytesArray);\n  const redeemScriptHash = hash160(redeemScript);\n  return bytesToHex(redeemScriptHash);\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${bytesToHex(serialized)}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  return deserializeCV(hex);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) return hexToCV(response.result);\n  throw new Error(response.cause);\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const validateTxId = (txid: string): boolean => {\n  if (txid === 'success') return true; // Bypass fetchMock tests // todo: move this line into mocks in test files\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}