{"ast":null,"code":"import { bytesToHex, bytesToUtf8, getGlobalObject, hexToBytes, makeUUID4, nextMonth, utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, makeECPrivateKey, publicKeyToBtcAddress } from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\nconst VERSION = '1.4.0';\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport const makeAuthRequest = makeAuthRequestToken;\nexport function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI, scopes = DEFAULT_SCOPE.slice(), appDomain, expiresAt = nextMonth().getTime(), extraParams = {}) {\n  const getWindowOrigin = paramName => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location?.origin;\n  };\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\nexport async function makeAuthResponse(privateKey, profile = {}, metadata, coreToken = null, appPrivateKey = null, expiresAt = nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null, appPrivateKeyFromWalletSalt = null) {\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {}\n  const payload = Object.assign({}, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    appPrivateKeyFromWalletSalt,\n    profile,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":{"version":3,"names":["bytesToHex","bytesToUtf8","getGlobalObject","hexToBytes","makeUUID4","nextMonth","utf8ToBytes","decryptECIES","encryptECIES","makeECPrivateKey","publicKeyToBtcAddress","SECP256K1Client","TokenSigner","DEFAULT_SCOPE","makeDIDFromAddress","VERSION","generateTransitKey","transitKey","makeAuthRequest","makeAuthRequestToken","transitPrivateKey","redirectURI","manifestURI","scopes","slice","appDomain","expiresAt","getTime","extraParams","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","origin","payload","Object","assign","jti","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","derivePublicKey","address","tokenSigner","token","sign","encryptPrivateKey","privateKey","encryptedObj","encryptedJSON","JSON","stringify","decryptPrivateKey","hexedEncrypted","unhexedString","parse","decrypted","Error","makeAuthResponse","profile","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","appPrivateKeyFromWalletSalt","privateKeyPayload","coreTokenPayload","additionalProperties","undefined","email","profile_url","profileUrl","private_key","core_token"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\auth\\src\\messages.ts"],"sourcesContent":["import {\n  bytesToHex,\n  bytesToUtf8,\n  getGlobalObject,\n  hexToBytes,\n  makeUUID4,\n  nextMonth,\n  utf8ToBytes,\n} from '@stacks/common';\nimport {\n  decryptECIES,\n  encryptECIES,\n  makeECPrivateKey,\n  publicKeyToBtcAddress,\n} from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { AuthScope, DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\n\nconst VERSION = '1.4.0';\n\ntype AuthMetadata = {\n  email?: string;\n  profileUrl?: string;\n};\n\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\n\n/** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\nexport const makeAuthRequest = makeAuthRequestToken;\n\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nexport function makeAuthRequestToken(\n  transitPrivateKey: string,\n  redirectURI?: string,\n  manifestURI?: string,\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\n  appDomain?: string,\n  expiresAt: number = nextMonth().getTime(),\n  extraParams: any = {}\n): string {\n  const getWindowOrigin = (paramName: string) => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n    });\n    return location?.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  /* Create the payload */\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes,\n  });\n\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\n\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n\n  return token;\n}\n\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\n\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nexport async function decryptPrivateKey(\n  privateKey: string,\n  hexedEncrypted: string\n): Promise<string | null> {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nexport async function makeAuthResponse(\n  privateKey: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  profile: {} = {},\n  metadata: AuthMetadata | null,\n  coreToken: string | null = null,\n  appPrivateKey: string | null = null,\n  expiresAt: number = nextMonth().getTime(),\n  transitPublicKey: string | null = null,\n  hubUrl: string | null = null,\n  blockstackAPIUrl: string | null = null,\n  associationToken: string | null = null,\n  appPrivateKeyFromWalletSalt: string | null = null\n): Promise<string> {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n\n  /* See if we should encrypt with the transit key */\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION,\n    };\n  } else {\n    // Logger.info('blockstack.js: generating legacy auth response')\n  }\n\n  /* Create the payload */\n  const payload = Object.assign(\n    {},\n    {\n      jti: makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n      iss: makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      appPrivateKeyFromWalletSalt,\n      profile,\n      core_token: coreTokenPayload,\n    },\n    additionalProperties\n  );\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}