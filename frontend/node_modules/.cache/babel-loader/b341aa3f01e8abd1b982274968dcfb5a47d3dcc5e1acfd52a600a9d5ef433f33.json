{"ast":null,"code":"import { isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { publicKeyToBtcAddress } from '@stacks/encryption';\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { fetchAppManifest } from './provider';\nexport function doSignaturesMatchPublicKeys(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys;\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\nexport function doPublicKeysMatchIssuer(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToBtcAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n  return false;\n}\nexport function isIssuanceDateValid(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    const issuedAt = new Date(payload.iat * 1000);\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isExpirationDateValid(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    const expiresAt = new Date(payload.exp * 1000);\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isManifestUriValid(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport async function verifyAuthRequest(token) {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n  const values = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n  return values.every(val => val);\n}\nexport async function verifyAuthRequestAndLoadManifest(token) {\n  const valid = await verifyAuthRequest(token);\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n  return fetchAppManifest(token);\n}\nexport async function verifyAuthResponse(token) {\n  const conditions = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token)]);\n  return conditions.every(val => val);\n}","map":{"version":3,"names":["isSameOriginAbsoluteUrl","publicKeyToBtcAddress","decodeToken","TokenVerifier","getAddressFromDID","fetchAppManifest","doSignaturesMatchPublicKeys","token","payload","Error","publicKeys","public_keys","length","publicKey","tokenVerifier","verify","e","doPublicKeysMatchIssuer","addressFromIssuer","iss","addressFromPublicKeys","isIssuanceDateValid","iat","issuedAt","Date","getTime","isExpirationDateValid","exp","expiresAt","isManifestUriValid","domain_name","manifest_uri","isRedirectUriValid","redirect_uri","verifyAuthRequest","header","alg","values","Promise","all","every","val","verifyAuthRequestAndLoadManifest","valid","verifyAuthResponse","conditions"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\auth\\src\\verification.ts"],"sourcesContent":["import { isSameOriginAbsoluteUrl } from '@stacks/common';\r\nimport { publicKeyToBtcAddress } from '@stacks/encryption';\r\nimport { decodeToken, TokenVerifier } from 'jsontokens';\r\nimport { getAddressFromDID } from './dids';\r\nimport { fetchAppManifest } from './provider';\r\n\r\n/**\r\n * Checks if the ES256k signature on passed `token` match the claimed public key\r\n * in the payload key `public_keys`.\r\n *\r\n * @param  {String} token encoded and signed authentication token\r\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\r\n * @throws {Error} if `token` contains multiple public keys\r\n * @private\r\n * @ignore\r\n */\r\nexport function doSignaturesMatchPublicKeys(token: string): boolean {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  const publicKeys = payload.public_keys as string[];\r\n  if (publicKeys.length === 1) {\r\n    const publicKey = publicKeys[0];\r\n    try {\r\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\r\n      return tokenVerifier.verify(token);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  } else {\r\n    throw new Error('Multiple public keys are not supported');\r\n  }\r\n}\r\n\r\n/**\r\n * Makes sure that the identity address portion of\r\n * the decentralized identifier passed in the issuer `iss`\r\n * key of the token matches the public key\r\n *\r\n * @param  {String} token encoded and signed authentication token\r\n * @return {Boolean} if the identity address and public keys match\r\n * @throws {Error} if ` token` has multiple public keys\r\n * @private\r\n * @ignore\r\n */\r\nexport function doPublicKeysMatchIssuer(token: string): boolean {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  const publicKeys = payload.public_keys as string[];\r\n  const addressFromIssuer = getAddressFromDID(payload.iss);\r\n\r\n  if (publicKeys.length === 1) {\r\n    const addressFromPublicKeys = publicKeyToBtcAddress(publicKeys[0]);\r\n    if (addressFromPublicKeys === addressFromIssuer) {\r\n      return true;\r\n    }\r\n  } else {\r\n    throw new Error('Multiple public keys are not supported');\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Checks if the if the token issuance time and date is after the\r\n * current time and date.\r\n *\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if the token was issued after the current time,\r\n * otherwise returns `false`\r\n * @private\r\n * @ignore\r\n */\r\nexport function isIssuanceDateValid(token: string) {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  if (payload.iat) {\r\n    if (typeof payload.iat !== 'number') {\r\n      return false;\r\n    }\r\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\r\n    if (new Date().getTime() < issuedAt.getTime()) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the expiration date of the `token` is before the current time\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\r\n * if the `token` has expired\r\n *\r\n * @private\r\n * @ignore\r\n */\r\nexport function isExpirationDateValid(token: string) {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  if (payload.exp) {\r\n    if (typeof payload.exp !== 'number') {\r\n      return false;\r\n    }\r\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\r\n    if (new Date().getTime() > expiresAt.getTime()) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Makes sure the `manifest_uri` is a same origin absolute URL.\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if valid, otherwise `false`\r\n * @private\r\n * @ignore\r\n */\r\nexport function isManifestUriValid(token: string) {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.manifest_uri as string);\r\n}\r\n\r\n/**\r\n * Makes sure the `redirect_uri` is a same origin absolute URL.\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if valid, otherwise `false`\r\n * @private\r\n * @ignore\r\n */\r\nexport function isRedirectUriValid(token: string) {\r\n  const payload = decodeToken(token).payload;\r\n  if (typeof payload === 'string') {\r\n    throw new Error('Unexpected token payload type of string');\r\n  }\r\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.redirect_uri as string);\r\n}\r\n\r\n/**\r\n * Verify authentication request is valid. This function performs a number\r\n * of checks on the authentication request token:\r\n * * Checks that `token` has a valid issuance date & is not expired\r\n * * Checks that `token` has a valid signature that matches the public key it claims\r\n * * Checks that both the manifest and redirect URLs are absolute and conform to\r\n * the same origin policy\r\n *\r\n * @param  {String} token encoded and signed authentication request token\r\n * @return {Promise} that resolves to true if the auth request\r\n *  is valid and false if it does not. It rejects with a String if the\r\n *  token is not signed\r\n * @private\r\n * @ignore\r\n */\r\nexport async function verifyAuthRequest(token: string): Promise<boolean> {\r\n  if (decodeToken(token).header.alg === 'none') {\r\n    throw new Error('Token must be signed in order to be verified');\r\n  }\r\n  const values = await Promise.all([\r\n    isExpirationDateValid(token),\r\n    isIssuanceDateValid(token),\r\n    doSignaturesMatchPublicKeys(token),\r\n    doPublicKeysMatchIssuer(token),\r\n    isManifestUriValid(token),\r\n    isRedirectUriValid(token),\r\n  ]);\r\n  return values.every(val => val);\r\n}\r\n\r\n/**\r\n * Verify the authentication request is valid and\r\n * fetch the app manifest file if valid. Otherwise, reject the promise.\r\n * @param  {String} token encoded and signed authentication request token\r\n * @return {Promise} that resolves to the app manifest file in JSON format\r\n * or rejects if the auth request or app manifest file is invalid\r\n * @private\r\n * @ignore\r\n */\r\nexport async function verifyAuthRequestAndLoadManifest(token: string): Promise<any> {\r\n  const valid = await verifyAuthRequest(token);\r\n  if (!valid) {\r\n    throw new Error('Token is an invalid auth request');\r\n  }\r\n  return fetchAppManifest(token);\r\n}\r\n\r\n/**\r\n * Verify the authentication response is valid.\r\n * @param {String} token the authentication response token\r\n * @return {Promise} that resolves to true if auth response\r\n * is valid and false if it does not\r\n * @private\r\n * @ignore\r\n */\r\nexport async function verifyAuthResponse(token: string): Promise<boolean> {\r\n  const conditions = await Promise.all([\r\n    isExpirationDateValid(token),\r\n    isIssuanceDateValid(token),\r\n    doSignaturesMatchPublicKeys(token),\r\n    doPublicKeysMatchIssuer(token),\r\n  ]);\r\n  return conditions.every(val => val);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}