{"ast":null,"code":"import { concatArray, concatBytes, bigIntToBytes, toTwos, writeUInt32BE, utf8ToBytes, asciiToBytes } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport { ClarityType } from './constants';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\nfunction bytesWithTypeID(typeId, bytes) {\n  return concatArray([typeId, bytes]);\n}\nfunction serializeBoolCV(value) {\n  return new Uint8Array([value.type]);\n}\nfunction serializeOptionalCV(cv) {\n  if (cv.type === ClarityType.OptionalNone) {\n    return new Uint8Array([cv.type]);\n  } else {\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\nfunction serializeBufferCV(cv) {\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.buffer.length, 0);\n  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\n}\nfunction serializeIntCV(cv) {\n  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeUIntCV(cv) {\n  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeStandardPrincipalCV(cv) {\n  return bytesWithTypeID(cv.type, serializeAddress(cv.address));\n}\nfunction serializeContractPrincipalCV(cv) {\n  return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));\n}\nfunction serializeResponseCV(cv) {\n  return bytesWithTypeID(cv.type, serializeCV(cv.value));\n}\nfunction serializeListCV(cv) {\n  const bytesArray = [];\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, cv.list.length, 0);\n  bytesArray.push(length);\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    bytesArray.push(serializedValue);\n  }\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeTupleCV(cv) {\n  const bytesArray = [];\n  const length = new Uint8Array(4);\n  writeUInt32BE(length, Object.keys(cv.data).length, 0);\n  bytesArray.push(length);\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    bytesArray.push(serializeLPString(nameWithLength));\n    const serializedValue = serializeCV(cv.data[key]);\n    bytesArray.push(serializedValue);\n  }\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringCV(cv, encoding) {\n  const bytesArray = [];\n  const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\n  const len = new Uint8Array(4);\n  writeUInt32BE(len, str.length, 0);\n  bytesArray.push(len);\n  bytesArray.push(str);\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringAsciiCV(cv) {\n  return serializeStringCV(cv, 'ascii');\n}\nfunction serializeStringUtf8CV(cv) {\n  return serializeStringCV(cv, 'utf8');\n}\nexport function serializeCV(value) {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}","map":{"version":3,"names":["concatArray","concatBytes","bigIntToBytes","toTwos","writeUInt32BE","utf8ToBytes","asciiToBytes","serializeAddress","serializeLPString","createLPString","ClarityType","SerializationError","CLARITY_INT_BYTE_SIZE","CLARITY_INT_SIZE","bytesWithTypeID","typeId","bytes","serializeBoolCV","value","Uint8Array","type","serializeOptionalCV","cv","OptionalNone","serializeCV","serializeBufferCV","length","buffer","serializeIntCV","BigInt","serializeUIntCV","serializeStandardPrincipalCV","address","serializeContractPrincipalCV","contractName","serializeResponseCV","serializeListCV","bytesArray","list","push","serializedValue","serializeTupleCV","Object","keys","data","lexicographicOrder","sort","a","b","localeCompare","key","nameWithLength","serializeStringCV","encoding","str","len","serializeStringAsciiCV","serializeStringUtf8CV","BoolTrue","BoolFalse","OptionalSome","Buffer","UInt","Int","PrincipalStandard","PrincipalContract","ResponseOk","ResponseErr","List","Tuple","StringASCII","StringUTF8"],"sources":["C:\\Users\\Pedro\\ADAD2324\\frontend\\node_modules\\@stacks\\transactions\\src\\clarity\\serialize.ts"],"sourcesContent":["import {\r\n  concatArray,\r\n  concatBytes,\r\n  bigIntToBytes,\r\n  toTwos,\r\n  writeUInt32BE,\r\n  utf8ToBytes,\r\n  asciiToBytes,\r\n} from '@stacks/common';\r\nimport { serializeAddress, serializeLPString } from '../types';\r\nimport { createLPString } from '../postcondition-types';\r\nimport {\r\n  BooleanCV,\r\n  OptionalCV,\r\n  BufferCV,\r\n  IntCV,\r\n  UIntCV,\r\n  StandardPrincipalCV,\r\n  ContractPrincipalCV,\r\n  ResponseCV,\r\n  ListCV,\r\n  TupleCV,\r\n  ClarityValue,\r\n} from '.';\r\nimport { ClarityType } from './constants';\r\n\r\nimport { SerializationError } from '../errors';\r\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\r\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\r\n\r\nfunction bytesWithTypeID(typeId: ClarityType, bytes: Uint8Array): Uint8Array {\r\n  return concatArray([typeId, bytes]);\r\n}\r\n\r\nfunction serializeBoolCV(value: BooleanCV): Uint8Array {\r\n  return new Uint8Array([value.type]);\r\n}\r\n\r\nfunction serializeOptionalCV(cv: OptionalCV): Uint8Array {\r\n  if (cv.type === ClarityType.OptionalNone) {\r\n    return new Uint8Array([cv.type]);\r\n  } else {\r\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\r\n  }\r\n}\r\n\r\nfunction serializeBufferCV(cv: BufferCV): Uint8Array {\r\n  const length = new Uint8Array(4);\r\n  writeUInt32BE(length, cv.buffer.length, 0);\r\n  return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\r\n}\r\n\r\nfunction serializeIntCV(cv: IntCV): Uint8Array {\r\n  const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\r\n  return bytesWithTypeID(cv.type, bytes);\r\n}\r\n\r\nfunction serializeUIntCV(cv: UIntCV): Uint8Array {\r\n  const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\r\n  return bytesWithTypeID(cv.type, bytes);\r\n}\r\n\r\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Uint8Array {\r\n  return bytesWithTypeID(cv.type, serializeAddress(cv.address));\r\n}\r\n\r\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Uint8Array {\r\n  return bytesWithTypeID(\r\n    cv.type,\r\n    concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName))\r\n  );\r\n}\r\n\r\nfunction serializeResponseCV(cv: ResponseCV) {\r\n  return bytesWithTypeID(cv.type, serializeCV(cv.value));\r\n}\r\n\r\nfunction serializeListCV(cv: ListCV) {\r\n  const bytesArray = [];\r\n\r\n  const length = new Uint8Array(4);\r\n  writeUInt32BE(length, cv.list.length, 0);\r\n  bytesArray.push(length);\r\n\r\n  for (const value of cv.list) {\r\n    const serializedValue = serializeCV(value);\r\n    bytesArray.push(serializedValue);\r\n  }\r\n\r\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\r\n}\r\n\r\nfunction serializeTupleCV(cv: TupleCV) {\r\n  const bytesArray = [];\r\n\r\n  const length = new Uint8Array(4);\r\n  writeUInt32BE(length, Object.keys(cv.data).length, 0);\r\n  bytesArray.push(length);\r\n\r\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\r\n\r\n  for (const key of lexicographicOrder) {\r\n    const nameWithLength = createLPString(key);\r\n    bytesArray.push(serializeLPString(nameWithLength));\r\n\r\n    const serializedValue = serializeCV(cv.data[key]);\r\n    bytesArray.push(serializedValue);\r\n  }\r\n\r\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\r\n}\r\n\r\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\r\n  const bytesArray = [];\r\n\r\n  const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\r\n  const len = new Uint8Array(4);\r\n  writeUInt32BE(len, str.length, 0);\r\n\r\n  bytesArray.push(len);\r\n  bytesArray.push(str);\r\n\r\n  return bytesWithTypeID(cv.type, concatArray(bytesArray));\r\n}\r\n\r\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\r\n  return serializeStringCV(cv, 'ascii');\r\n}\r\n\r\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\r\n  return serializeStringCV(cv, 'utf8');\r\n}\r\n\r\n/**\r\n * Serializes clarity value to Uint8Array\r\n *\r\n * @param {ClarityValue} value to be converted to bytes\r\n **\r\n * @returns {Uint8Array} returns the bytes\r\n *\r\n * @example\r\n * ```\r\n *  import { intCV, serializeCV } from '@stacks/transactions';\r\n *\r\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\r\n *\r\n *  // <Uint8Array 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\r\n * ```\r\n *\r\n * @see\r\n * {@link https://github.com/hirosystems/stacks.js/blob/main/packages/transactions/tests/clarity.test.ts | clarity test cases for more examples}\r\n */\r\nexport function serializeCV(value: ClarityValue): Uint8Array {\r\n  switch (value.type) {\r\n    case ClarityType.BoolTrue:\r\n    case ClarityType.BoolFalse:\r\n      return serializeBoolCV(value);\r\n    case ClarityType.OptionalNone:\r\n    case ClarityType.OptionalSome:\r\n      return serializeOptionalCV(value);\r\n    case ClarityType.Buffer:\r\n      return serializeBufferCV(value);\r\n    case ClarityType.UInt:\r\n      return serializeUIntCV(value);\r\n    case ClarityType.Int:\r\n      return serializeIntCV(value);\r\n    case ClarityType.PrincipalStandard:\r\n      return serializeStandardPrincipalCV(value);\r\n    case ClarityType.PrincipalContract:\r\n      return serializeContractPrincipalCV(value);\r\n    case ClarityType.ResponseOk:\r\n    case ClarityType.ResponseErr:\r\n      return serializeResponseCV(value);\r\n    case ClarityType.List:\r\n      return serializeListCV(value);\r\n    case ClarityType.Tuple:\r\n      return serializeTupleCV(value);\r\n    case ClarityType.StringASCII:\r\n      return serializeStringAsciiCV(value);\r\n    case ClarityType.StringUTF8:\r\n      return serializeStringUtf8CV(value);\r\n    default:\r\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}